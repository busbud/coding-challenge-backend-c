{
  "name": "fuzzysearch-js",
  "version": "0.1.1",
  "description": "FuzzySearching in JS",
  "main": "js/FuzzySearch.js",
  "scripts": {},
  "author": {
    "name": "Steffen Persch",
    "url": "n3on"
  },
  "keywords": [
    "fuzzysearch",
    "search",
    "fuzzy",
    "approximate string matching",
    "fuzzy searching",
    "suggestions"
  ],
  "repository": {
    "type": "git",
    "url": "git@github.com:unlooped/FuzzySearchJS.git"
  },
  "license": "MIT",
  "dependencies": {
    "prime": "0.3.x",
    "levenshtein": "*"
  },
  "devDependencies": {
    "mocha": "1.3",
    "expect.js": "0.1",
    "jshint": "0.9",
    "elements": "0.2.x"
  },
  "readme": "FuzzySearchJS\n=============\n\nPrime Implementation for fuzzy searching.\n\nFuzzySearchJS provides an easy and modular way for fuzzy searching in JS for multiple purposes.\n\nSpecial thanks to Arian Stolwijk and Dimitar Christoff for some early reviews and some ideas.\n\n## Quick Start: ##\n\nInstall:\n```js\nnpm install fuzzysearch-js\n```\n\nUsage:\n```js\nvar FuzzySearch = require('fuzzysearch-js');\nvar levenshteinFS = require('fuzzysearch-js/js/modules/LevenshteinFS');\nvar indexOfFS = require('fuzzysearch-js/js/modules/IndexOfFS');\nvar wordCountFS = require('fuzzysearch-js/js/modules/WordCountFS');\n\nvar data = ['Hydrogen','Helium','Lithium','Beryllium'];\n\nvar fuzzySearch = new FuzzySearch(data, {'minimumScore': 300});\nfuzzySearch.addModule(levenshteinFS({'maxDistanceTolerance': 3, 'factor': 3}));\nfuzzySearch.addModule(indexOfFS({'minTermLength': 3, 'maxIterations': 500, 'factor': 3}));\nfuzzySearch.addModule(wordCountFS({'maxWordTolerance': 3, 'factor': 1}));\n\nvar result = fuzzySearch.search('Hlium');\nconsole.log(result);\n```\n\n## Todo: ##\n\n- Add tests for Modules\n- Implement own Levenshtein algorithm for improving performance. It's not neccessary to calculate the whole number everytime. You can calculate the first rows and everytime a new letter is added you can just calculate the next row. Also if your tolerance is reached you can stop calculate the other rows.\n- Play around with factors for best results. Maybe some presets for different situations. It's a big difference if you make a live search or if you make a search with the full term.\n- Take a closer look at Sift3 algorithm. Maybe there also is some potential for performance optimizations.\n- Implement caching for results\n- Implement that the user choice can be transfered to server, so maybe this also could be a source.\n- Implement that caching for the same resultset can be preloaded from server.\n- Make better examples and better readme\n\n## About / Idea behind this project / How does it work? ##\n\nI build FuzzySearchJS because I needed something more or less accurate for live searching through categories and stuff like that.\nAt the beginning i've done something very simple like just get all the available data and make an indexOf call, if it doesn't return -1 I got a hit and added this into my result array.\nThis works not that bad because you get results even if it is not exactly right or just matches some letters in your data set. For example:\n\nData:\n```js\nvar dataSet = ['Hydrogen','Helium','Lithium','Beryllium','Boron','Carbon'];\n```\n\nIf you type in 'lium' for example your results will be Helium and Beryllium which is not that bad for a user who just want to get less results to choose from.\nBut surely this will bring up some problems. What is if the user doesn't know how things are spelled. Or if he types 'lieum' which is a little mistake but he won't get any results and this sucks.\nThat's why I came up with a bit more complicated solution. I began writing a small algorithm which is based on the Levenshtein Algorithm which returns an integer of how many differences in words are. Or easier said \"how many mistakes is the word away from being correct\".\nThis algorithm works well if you just compare one word to another, but if you want to filter the results live as the user types you get some problems.\nBecause if your search term is just 1, 2 or 3 letters big the Levenshtein algorithm returns a large number of differences.\nI.E. The user just typed: \"hyd\", the first value in your dataset is \"Hydrogen\" and the levenshtein algorithm returns 6 because h is lowercase, and there are 5 missing letters (rogen). Even if you are not case sensitive you still get back 5 which is way too much even if you could probably say the user is searching for \"hydrogen\".\nSo you have to combine some different methods to get good and accurate results. And as more the user types and specifies the search you get more to worry about. Because you always want to display the closest result on top.\nThat's why I introduced modules. Because for every purpose you need different criteria to decide which results are the best. If you want to get good live typing results, indexOf works pretty well, but if a word is completed, levenshtein will work much better.\nIf the user just searches with full terms a simple indexOf search is useless because it just would match if everything is right. What is if You have 3 words?\nI.E.\n```js\nvar value = \"JavaScript DOM Framework\";\n```\nNow the user types in \"dom framework javascript\" you got a very close match because all the words are matched. But you have to compare each word by word, also the order of the keywords are relevant. If you have something in your dataset like \"dom javascript framework\" you want to display this before \"Javascript dom Framework\" because it is closer at the user search.\nThat's why i created some modules for the first release of this project. You can easily write your own module and so get better results for your purpose.\nEvery module returns a number between 0 and 100. 100 means a perfect match, 0 is not relevant. For every module you can define a factor, because some things are only important if there is a small difference (i.E. the word count, it's just relevant if everything else matches perfectly).\nSo as more modules you add as higher your combinedScore will be for a match. If you add 2 modules with factor 1, your highest score can be 200. If you change the factor for one module to 3, your highest score will be 400. And so on. There is no limit.\nIf you added all the modules, you can ask for the maximum score:\n```js\nfuzzySearch.getMaximumScore();\n```\nYou can also set a minimum score which should be reached that the data will included in the resultset.\n\n## How to (just some thoughts / mindstorming) ##\n```js\nvar dataSet = ['Hydrogen','Helium','Lithium','Beryllium','Boron','Carbon','Nitrogen','Oxygen','Fluorine','Neon','Sodium','Magnesium','Aluminum, Aluminium','Silicon','Phosphorus','Sulfur','Chlorine','Argon','Potassium','Calcium','Scandium','Titanium','Vanadium','Chromium','Manganese','Iron','Cobalt','Nickel','Copper','Zinc','Gallium','Germanium','Arsenic','Selenium','Bromine','Krypton','Rubidium','Strontium','Yttrium','Zirconium','Niobium','Molybdenum','Technetium','Ruthenium','Rhodium','Palladium','Silver','Cadmium','Indium','Tin','Antimony','Tellurium','Iodine','Xenon','Cesium','Barium','Lanthanum','Cerium','Praseodymium','Neodymium','Promethium','Samarium','Europium','Gadolinium','Terbium','Dysprosium','Holmium','Erbium','Thulium','Ytterbium','Lutetium','Hafnium','Tantalum','Tungsten','Rhenium','Osmium','Iridium','Platinum','Gold','Mercury','Thallium','Lead','Bismuth','Polonium','Astatine','Radon','Francium','Radium','Actinium','Thorium','Protactinium','Uranium','Neptunium','Plutonium','Americium','Curium','Berkelium','Californium','Einsteinium','Fermium','Mendelevium','Nobelium','Lawrencium','Rutherfordium','Dubnium','Seaborgium','Bohrium','Hassium','Meitnerium','Darmstadtium','Roentgenium','Copernicium','Ununtrium','Flerovium','Ununpentium','Livermorium','Ununseptium','Ununoctium'];\n```\n\n\nFirst you have to create a new FuzzySearch instance:\n\navailable options + defaults:\n```js\n'caseSensitive': false, //if set to true, all the comparisons will be done lowerCase\n'termPath': '', //if you have objects in your data set you can set the path to the value you are searching through\n'minimumScore': 0,//the minimum combinedScore which must be reached that the value is included in the result set\n'returnEmptyArray': false //false: if no results are found it returns null. true: if no results are found it returns an empty array\n```\n\n```js\nvar FuzzySearch = require('./FuzzySearch');\nvar fuzzySearch = new FuzzySearch(dataSet, {'caseSensitive': false});\n```\n\nNow you should add some modules you like to use. At the moment the following are available:\n\n- IndexOf Search\n- Levenshtein\n- Sift3 â€“ similar to levenshtein\n- word count\n\n```js\nvar LevenshteinFS = require('./modules/LevenshteinFS');\nvar IndexOfFS = require('./modules/IndexOfFS');\nvar WordCountFS = require('./modules/WordCountFS');\n\nfuzzySearch.addModule(LevenshteinFS({'maxDistanceTolerance': 3, 'factor': 3}));\nfuzzySearch.addModule(IndexOfFS({'minTermLength': 3, 'maxIterations': 500, 'factor': 3}));\nfuzzySearch.addModule(WordCountFS({'maxWordTolerance': 3, 'factor': 1}));\n```\n\nNow you are ready to go:\n\n```js\nfuzzySearch.search('Hlium');\n```\n\nReturns an array like this:\n\n```js\n[\n    {\"score\":590,\n     \"details\":[\n        {\"name\":\"LevenshteinFS\",\"score\":83.33333333333334,\"factor\":3},\n        {\"name\":\"IndexOfFS\",\"score\":80,\"factor\":3},\n        {\"name\":\"WordCountFS\",\"score\":100,\"factor\":1}\n     ],\n     \"value\":\"Helium\"\n     },\n     {\"score\":490,\n      \"details\":[\n        {\"name\":\"LevenshteinFS\",\"score\":50,\"factor\":3},\n        {\"name\":\"IndexOfFS\",\"score\":80,\"factor\":3},\n        {\"name\":\"WordCountFS\",\"score\":100,\"factor\":1}\n      ],\n      \"value\":\"Gallium\"},\n      ...\n```\n\nLike you see you get an overall score which indicates how close the match is.\nYou also get an array with more details, you see in there the score of every module and the factor by which the score is multiplied.\nAnd for sure, in the \"value\" field you will find the value from the dataset.\n\n## Objects ##\n\nYou can also search through objects. Just pass an array with objects as your dataset and set a \"termPath\" as option when instanciation FuzzySearch:\n\n```js\nvar dataSet = [{'id': 1, 'demo': {'element': 'Hydrogen'}}, {'id': 2, 'demo': {'element': 'Helium'}}, {'id': 3, 'demo': {'element': 'Lithium'}}];\nvar fuzzySearch = new FuzzySearch(dataSet, {'caseSensitive': false, 'termPath': 'demo.element'});\n```\n\nNow your result would look something like this:\n\n```js\n[\n    {\"score\":590,\n     \"details\":[\n        {\"name\":\"LevenshteinFS\",\"score\":83.33333333333334,\"factor\":3},\n        {\"name\":\"IndexOfFS\",\"score\":80,\"factor\":3},\n        {\"name\":\"WordCountFS\",\"score\":100,\"factor\":1}\n     ],\n     \"value\": {'id': 1, 'demo': {'element': 'Hydrogen'}}\n     },\n     {\"score\":490,\n      \"details\":[\n        {\"name\":\"LevenshteinFS\",\"score\":50,\"factor\":3},\n        {\"name\":\"IndexOfFS\",\"score\":80,\"factor\":3},\n        {\"name\":\"WordCountFS\",\"score\":100,\"factor\":1}\n      ],\n      \"value\":{'id': 2, 'demo': {'element': 'Helium'}}\n     },\n     ...\n```\n\n## Testing ##\n\nMac OS X Terminal or Linux Terminal.\n\n```\ncd FuzzySearchJS\nmake test\n```\n\n# Modules #\n\n## LevenshteinFS ##\n\n```js\nvar LevenshteinFS = require('./modules/LevenshteinFS');\n```\n\noptions:\n```js\n'maxDistanceTolerance': 3, //if the distance is higher than 3 this module returns 0\n'factor': 1\n```\n\n## Sift3FS ###\n\n```js\nvar Sift3FS = require('./modules/Sift3FS');\n```\n\noptions:\n```js\n'maxDistanceTolerance': 3, //if the distance is higher than 3 this module returns 0\n'factor': 1\n```\n\n## IndexOfFS ##\n\nEven if it sounds like an easy indexOf this is much more. It is a bit mistake tolerant and also dynamic in the minimum term length.\nPlease take a look at the source code until I find more time to explain it in detail. Or feel free to write one :)\n\n```js\nvar IndexOfFS = require('./modules/IndexOfFS');\n```\n\noptions:\n```js\n'minTermLength': 3,\n'maxIterations': 500,\n'factor': 1\n```\n\n## WordCountFS ##\n\n```js\nvar WordCountFS = require('./modules/WordCountFS');\n```\n\noptions:\n```js\n'maxWordTolerance': 3,\n'factor': 1\n```\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/unlooped/FuzzySearchJS/issues"
  },
  "homepage": "https://github.com/unlooped/FuzzySearchJS",
  "_id": "fuzzysearch-js@0.1.1",
  "_from": "fuzzysearch-js@"
}

{
  "name": "wrapup",
  "description": "wraps up node packages for web development",
  "version": "0.10.3",
  "license": "MIT (http://mootools.net/license.txt)",
  "main": "./lib/main.js",
  "bin": {
    "wrup": "./bin/wrup.js"
  },
  "keywords": [
    "wrap",
    "wrapper",
    "wrapup",
    "wrup",
    "packager",
    "browser",
    "package manager"
  ],
  "homepage": "http://github.com/kamicane/wrapup",
  "author": {
    "name": "Valerio Proietti",
    "email": "@kamicane",
    "url": "http://mad4milk.net"
  },
  "bugs": {
    "url": "https://github.com/kamicane/wrapup/issues"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/kamicane/wrapup.git"
  },
  "dependencies": {
    "async": "0.1",
    "colors": "*",
    "clint": "0.0.6",
    "prime": "0.0.6",
    "uglify-js": "2.2",
    "graphviz": "0.0.x"
  },
  "devDependencies": {},
  "optionalDependencies": {},
  "engines": {
    "node": ">=0.6"
  },
  "scripts": {
    "test": "node ./test/run.js"
  },
  "readme": "![wrapup](http://github.com/kamicane/wrapup/raw/master/assets/wrapup.png)\n\n## WrapUp?\n\n * WrapUp compiles CommonJS 1.0 modules for the browser.\n * WrapUp does not try to have a working `require` implementation for the browser, infact the loader WrapUp uses is [incredibly simple](https://github.com/kamicane/wrapup/blob/master/includes/wrapper.js).\n * WrapUp ignores duplicates that may be present when using npm to install packages.\n * WrapUp supports building multiple versions of the same package.\n * WrapUp supports circular module dependencies.\n * WrapUp can watch source files for changes and rebuild automatically.\n\n[![Build Status](https://secure.travis-ci.org/mootools/wrapup.png)](https://travis-ci.org/mootools/wrapup)\n\n## Installation\n\nWrapUp is installed via npm:\n\n```\nnpm install wrapup -g\n```\n\nAfter that, you will have access to `wrup` in your cli.\n\n```\nwrup --help\n```\n\nYou can also install locally:\n\n```\nnpm install wrapup\n```\n\nAnd require WrapUp in your node javascripts:\n\n```js\nvar wrup = require(\"wrapup\")()\n```\n\n## Usage\n\nIn a nutshell, you tell WrapUp you require `something`, it calculates\ndependencies for `something` using static analysis, and compiles a single\nJavaScript file that only exposes that `something` you required. `require`\npaths inside modules are replaced with unique identifiers for brevity, and you\nwill only be able to access directly that `something` you required, never\ndependencies (unless specifically required).\n\n### require()\n\nThe main WrapUp method is `require(namespace, module)`.\n\nIt resolves a module using node's own modules and packages logic, so for\ninstance, `wrup.require(\"colors\")` would look in your `node_modules` folder for\na package named colors, then proceed to load its `main`. The namespace parameter\nis optional, but it's used to expose the module to the browser. Without a\nnamespace, the module will be required without being assigned. A bit like doing\n`var x = require(y)` vs `require(y)`.\n\n#### cli\n\n```\nwrup --require colors colors --require someName ./path/to/otherModule --require someOtherPackage\n```\n\n#### js\n\n```js\nvar wrup = require(\"wrapup\")() // require + instantiate\n\nwrup.require(\"colors\", \"colors\")\n    .require(\"someName\", \"./path/to/otherModule\")\n    .require(\"someOtherPackage\")\n    .options(/*...options...*/)\n    .up(function(err, js){\n        console.log(js)\n    })\n```\n\nthe above would let you access colors and someName, while having\nsomeOtherPackage simply required without being assigned to any variable. The\nouput code assigning variables would look like this:\n\n```js\nwindow.colors = require(\"colors\")\nwindow.someName = require(\"someName\")\nrequire(\"someOtherPackage\")\n```\n\n### watch\n\nWrapUp supports watching source files and rebuilds automatically whenever one of\nthese changes.\n\ncli: `--watch`\n\nInstead of using the `.up()` method, the `.watch()` method is used.\n\n```javascript\nvar wrup = require(\"wrapup\")() // require + instantiate\nwrup.require(\"y\", \"./moduley.js\").watch()\n\nwrup.on(\"data\", function(js){\n    fs.writeFile(\"path/to/wherever\", js)\n})\n\nwrup.on(\"change\", function(file){\n    console.log(file + \" changed.\")\n})\n```\n\nIn the above example, whenever module y and any module required by module y\nchanges, .up() is called again. The `data` event is fired whenever WrapUp\nbuilds, either be a direct .up() call or an .up() call triggered by a changed\nfile. The `change` event is fired whenever `watch` is set to true and one of the\nsource files changes.\n\n### options\n\nSet some options for the output.\n\n```js\nwrup.options({\n    globalize: \"MyNamespace\"\n})\n```\n\n - `globalize` define the global scope where named modules are attached to. Defaults to window.\n - `compress` if set to true, will compress the resulting javascript file using uglify-js. Defaults to false.\n - `output` only available in the cli, used to specify an output file. defaults to stdout.\n - `sourcemap` (cli: `--source-map`) Specify an output file where to generate source map.\n - `sourcemapURL` (cli: `--source-map-url`) `//@ sourceMappingURL` value, URL to the saved sourcemap file.\n - `sourcemapRoot` (cli: `--source-map-root`) The path to the original source to be included in the source map.\n - `sourcemapIn` (cli: `--in-source-map`) Input source map, useful if you're compressing JS that was generated from some other original code.\n\n#### cli\n\n```\nwrup --require ... --globalize MyNameSpace --compress --output path/to/file.js --watch\n```\n\n#### js\n\n```javascript\nwrup.require(/*...*/)\n    .require(/*...*/)\n    .options({\n        globalize: \"MyNameSpace\",\n        compress: true,\n        sourcemap: \"./somefile.map\"\n    }).on(\"data\", function(js){\n        fs.writeFile(\"./somefile.js\", js)\n    }).up()\n```\n\n### Using Source Maps\n\nWrapUp utilizes UglifyJS internally to create source-maps, and has the same\noptions, `--source-map`, `--source-map-root` and `--in-source-map`.\n\nOnce the `.map` file is created, the page with the JavaScript can be opened. It\nis important that the original files are accessible through http too. For example\nwhen using `--require ./test/a --source-map test.map --source-map-root\nhttp://foo.com/src` the file `http://foo.com/src/test/a.js` should be the\noriginal JavaScript module.\n\n### Using with Uglify-JS\n\nThe WrapUp output can be piped into UglifyJS if more compression options are\ndesired. For example using the `--define` option to set global definitions.\n\n```\nwrup -r ./main.js --source-map ./main.map \\\n     | uglify -d DEV=false --compress --mangle --output ./main.min.js \\\n              --source-map main.map --in-source-map main.map\n```\n\n### Stream and pipe\n\nWrapUp implements Node [Stream](http://nodejs.org/api/stream.html#stream_readable_stream)\nwhich means it is possible to pipe the WrapUp output to other writable streams,\nlike [fs.WriteStream](http://nodejs.org/api/fs.html#fs_fs_writestream),\nprocess.stdout or\n[http.ServerResponse](http://nodejs.org/api/http.html#http_class_http_serverresponse).\n\n```js\nhttp.createServer(function(req, res){\n    var wrup = wrapup()\n    wrup.require('prime')\n    wrup.pipe(res)\n    wrup.up()\n})\n```\n\n### Examples\n\ncoming soon... :)\n",
  "readmeFilename": "README.md",
  "_id": "wrapup@0.10.3",
  "_from": "wrapup@0.10"
}

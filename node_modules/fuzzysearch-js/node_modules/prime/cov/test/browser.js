(function(modules) {
    var cache = {}, require = function(id) {
        var module = cache[id];
        if (!module) {
            module = cache[id] = {};
            var exports = module.exports = {};
            modules[id].call(exports, require, module, exports, window);
        }
        return module.exports;
    };
    require("0")
})({
    "0": function(require, module, exports, global) {
        /*global mocha:true mochaPhantomJS:true */
        /*jshint browser:true */
                "use strict";

        mocha.setup("bdd");

        require("1");

        require("m");

        require("p");

        require("s");

        require("y");

        require("19");

        require("1b");

        require("1j");

        require("1k");

        require("1l");

        require("1m");

        require("1n");

        require("1o");

        require("1p");

        require("1q");

        require("1r");

        require("1s");

        require("1u");

        require("1x");

        require("1z");

        window.onload = function() {
            if (window.mochaPhantomJS) mochaPhantomJS.run(); else mocha.run();
        };
    },
    "1": function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var array = require("3");

        describe("es5/array", function() {
            function getTestArray() {
                var arr = [ 0, 1, 2, 3 ];
                delete arr[1];
                delete arr[2];
                return arr;
            }
            function isNumber(value) {
                return typeof value == "number";
            }
            describe("Array.filter", function() {
                it("should filter an array", function() {
                    var arr = [ 1, 2, 3, 0, 0, 0 ];
                    var testArr = array.filter(arr.concat([ false, null, 4 ]), isNumber);
                    expect(testArr).to.eql(arr.concat(4));
                });
                it("filter should not skip deleted elements", function() {
                    var i = 0;
                    array.filter(getTestArray(), function() {
                        i++;
                        return true;
                    });
                    expect(i).to.equal(4);
                });
                it("should return the original item, and not any mutations.", function() {
                    var result = array.filter([ 0, 1, 2 ], function(num, i, array) {
                        if (num == 1) {
                            array[i] = "mutation";
                            return true;
                        }
                    });
                    expect(result[0]).to.equal(1);
                });
            });
            describe("Array.indexOf", function() {
                it("should return the index of the item", function() {
                    expect(array.indexOf([ 1, 2, 3, 0, 0, 0 ], 0)).to.equal(3);
                });
                it("should return -1 if the item is not found in the array", function() {
                    expect(array.indexOf([ 1, 2, 3, 0, 0, 0 ], "not found")).to.equal(-1);
                });
                it("should not return -1 for undefined when the array is sparse", function() {
                    expect(array.indexOf(new Array(4), undefined)).to.equal(0);
                });
            });
            describe("Array.map", function() {
                it("should return a mapping of an array", function() {
                    var arr = array.map([ 1, 2, 3, 0, 0, 0 ], function(item) {
                        return item + 1;
                    });
                    expect(arr).to.eql([ 2, 3, 4, 1, 1, 1 ]);
                });
                it("should not skip deleted elements", function() {
                    var i = 0;
                    array.map(getTestArray(), function() {
                        return i++;
                    });
                    expect(i).to.equal(4);
                });
                it("should return an array with the same length", function() {
                    expect(array.map([ 1, 2, 3, undefined ], function(v) {
                        return v;
                    }).length).to.equal(4);
                });
                it("shoud return an empty array when the thisArg does not has a length property", function() {
                    expect(array.map({}, function() {
                        return 1;
                    })).to.eql([]);
                });
            });
            describe("Array.forEach", function() {
                it("should call the function for each item in Function arguments", function() {
                    var daysArr = [];
                    !function() {
                        array.forEach(arguments, function(value, key) {
                            daysArr[key] = value;
                        });
                    }("Sun", "Mon", "Tue");
                    expect(daysArr).to.eql([ "Sun", "Mon", "Tue" ]);
                });
                it("should call the function for each item in the array", function() {
                    var daysArr = [];
                    array.forEach([ "Sun", "Mon", "Tue" ], function(value, i) {
                        daysArr.push(value);
                    });
                    expect(daysArr).to.eql([ "Sun", "Mon", "Tue" ]);
                });
                it("should iterate over deleted elements", function() {
                    var arr = [ 0, 1, 2, 3 ], testArray = [];
                    delete arr[1];
                    delete arr[2];
                    array.forEach(arr, function(value) {
                        testArray.push(value);
                    });
                    expect(testArray).to.eql([ 0, undefined, undefined, 3 ]);
                });
            });
            describe("Array.every", function() {
                it("should return true if every item matches the comparator, otherwise false", function() {
                    expect(array.every([ 1, 2, 3, 0, 0, 0 ], isNumber)).to.be(true);
                    expect(array.every([ "1", 2, 3, 0 ], isNumber)).to.be(false);
                });
                it("should not skip deleted elements", function() {
                    var i = 0;
                    array.every(getTestArray(), function() {
                        i++;
                        return true;
                    });
                    expect(i).to.equal(4);
                });
            });
            describe("Array.some", function() {
                it("should return true if some of the items in the array match the comparator, otherwise false", function() {
                    expect(array.some([ "1", 2, 3, 0 ], isNumber)).to.be(true);
                    var arr = array.map([ 1, 2, 3, 0, 0, 0 ], String);
                    expect(array.some(arr, isNumber)).to.be(false);
                });
                it("should not skip deleted elements", function() {
                    var i = 0;
                    var a = getTestArray();
                    delete a[0];
                    array.some(a, function(value, index) {
                        i = index;
                        return true;
                    });
                    expect(i).to.equal(0);
                });
            });
            it("should accept thisArgs without length property", function() {
                var object = {}, fn = function() {};
                expect(array.every(object, fn)).to.be(true);
                expect(array.filter(object, fn)).to.eql([]);
                expect(array.indexOf(object)).to.equal(-1);
                expect(array.map(object, fn)).to.eql([]);
                expect(array.some(object, fn)).to.be(false);
            });
        });
    },
    "2": function(require, module, exports, global) {
                (function(global, module) {
            if ("undefined" == typeof module) {
                var module = {
                    exports: {}
                }, exports = module.exports;
            }
            /**
   * Exports.
   */
            module.exports = expect;
            expect.Assertion = Assertion;
            /**
   * Exports version.
   */
            expect.version = "0.1.2";
            /**
   * Possible assertion flags.
   */
            var flags = {
                not: [ "to", "be", "have", "include", "only" ],
                to: [ "be", "have", "include", "only", "not" ],
                only: [ "have" ],
                have: [ "own" ],
                be: [ "an" ]
            };
            function expect(obj) {
                return new Assertion(obj);
            }
            /**
   * Constructor
   *
   * @api private
   */
            function Assertion(obj, flag, parent) {
                this.obj = obj;
                this.flags = {};
                if (undefined != parent) {
                    this.flags[flag] = true;
                    for (var i in parent.flags) {
                        if (parent.flags.hasOwnProperty(i)) {
                            this.flags[i] = true;
                        }
                    }
                }
                var $flags = flag ? flags[flag] : keys(flags), self = this;
                if ($flags) {
                    for (var i = 0, l = $flags.length; i < l; i++) {
                        // avoid recursion
                        if (this.flags[$flags[i]]) continue;
                        var name = $flags[i], assertion = new Assertion(this.obj, name, this);
                        if ("function" == typeof Assertion.prototype[name]) {
                            // clone the function, make sure we dont touch the prot reference
                            var old = this[name];
                            this[name] = function() {
                                return old.apply(self, arguments);
                            };
                            for (var fn in Assertion.prototype) {
                                if (Assertion.prototype.hasOwnProperty(fn) && fn != name) {
                                    this[name][fn] = bind(assertion[fn], assertion);
                                }
                            }
                        } else {
                            this[name] = assertion;
                        }
                    }
                }
            }
            /**
   * Performs an assertion
   *
   * @api private
   */
            Assertion.prototype.assert = function(truth, msg, error) {
                var msg = this.flags.not ? error : msg, ok = this.flags.not ? !truth : truth;
                if (!ok) {
                    throw new Error(msg);
                }
                this.and = new Assertion(this.obj);
            };
            /**
   * Check if the value is truthy
   *
   * @api public
   */
            Assertion.prototype.ok = function() {
                this.assert(!!this.obj, "expected " + i(this.obj) + " to be truthy", "expected " + i(this.obj) + " to be falsy");
            };
            /**
   * Assert that the function throws.
   *
   * @param {Function|RegExp} callback, or regexp to match error string against
   * @api public
   */
            Assertion.prototype.throwError = Assertion.prototype.throwException = function(fn) {
                expect(this.obj).to.be.a("function");
                var thrown = false, not = this.flags.not;
                try {
                    this.obj();
                } catch (e) {
                    if ("function" == typeof fn) {
                        fn(e);
                    } else if ("object" == typeof fn) {
                        var subject = "string" == typeof e ? e : e.message;
                        if (not) {
                            expect(subject).to.not.match(fn);
                        } else {
                            expect(subject).to.match(fn);
                        }
                    }
                    thrown = true;
                }
                if ("object" == typeof fn && not) {
                    // in the presence of a matcher, ensure the `not` only applies to
                    // the matching.
                    this.flags.not = false;
                }
                var name = this.obj.name || "fn";
                this.assert(thrown, "expected " + name + " to throw an exception", "expected " + name + " not to throw an exception");
            };
            /**
   * Checks if the array is empty.
   *
   * @api public
   */
            Assertion.prototype.empty = function() {
                var expectation;
                if ("object" == typeof this.obj && null !== this.obj && !isArray(this.obj)) {
                    if ("number" == typeof this.obj.length) {
                        expectation = !this.obj.length;
                    } else {
                        expectation = !keys(this.obj).length;
                    }
                } else {
                    if ("string" != typeof this.obj) {
                        expect(this.obj).to.be.an("object");
                    }
                    expect(this.obj).to.have.property("length");
                    expectation = !this.obj.length;
                }
                this.assert(expectation, "expected " + i(this.obj) + " to be empty", "expected " + i(this.obj) + " to not be empty");
                return this;
            };
            /**
   * Checks if the obj exactly equals another.
   *
   * @api public
   */
            Assertion.prototype.be = Assertion.prototype.equal = function(obj) {
                this.assert(obj === this.obj, "expected " + i(this.obj) + " to equal " + i(obj), "expected " + i(this.obj) + " to not equal " + i(obj));
                return this;
            };
            /**
   * Checks if the obj sortof equals another.
   *
   * @api public
   */
            Assertion.prototype.eql = function(obj) {
                this.assert(expect.eql(obj, this.obj), "expected " + i(this.obj) + " to sort of equal " + i(obj), "expected " + i(this.obj) + " to sort of not equal " + i(obj));
                return this;
            };
            /**
   * Assert within start to finish (inclusive). 
   *
   * @param {Number} start
   * @param {Number} finish
   * @api public
   */
            Assertion.prototype.within = function(start, finish) {
                var range = start + ".." + finish;
                this.assert(this.obj >= start && this.obj <= finish, "expected " + i(this.obj) + " to be within " + range, "expected " + i(this.obj) + " to not be within " + range);
                return this;
            };
            /**
   * Assert typeof / instance of
   *
   * @api public
   */
            Assertion.prototype.a = Assertion.prototype.an = function(type) {
                if ("string" == typeof type) {
                    // proper english in error msg
                    var n = /^[aeiou]/.test(type) ? "n" : "";
                    // typeof with support for 'array'
                    this.assert("array" == type ? isArray(this.obj) : "object" == type ? "object" == typeof this.obj && null !== this.obj : type == typeof this.obj, "expected " + i(this.obj) + " to be a" + n + " " + type, "expected " + i(this.obj) + " not to be a" + n + " " + type);
                } else {
                    // instanceof
                    var name = type.name || "supplied constructor";
                    this.assert(this.obj instanceof type, "expected " + i(this.obj) + " to be an instance of " + name, "expected " + i(this.obj) + " not to be an instance of " + name);
                }
                return this;
            };
            /**
   * Assert numeric value above _n_.
   *
   * @param {Number} n
   * @api public
   */
            Assertion.prototype.greaterThan = Assertion.prototype.above = function(n) {
                this.assert(this.obj > n, "expected " + i(this.obj) + " to be above " + n, "expected " + i(this.obj) + " to be below " + n);
                return this;
            };
            /**
   * Assert numeric value below _n_.
   *
   * @param {Number} n
   * @api public
   */
            Assertion.prototype.lessThan = Assertion.prototype.below = function(n) {
                this.assert(this.obj < n, "expected " + i(this.obj) + " to be below " + n, "expected " + i(this.obj) + " to be above " + n);
                return this;
            };
            /**
   * Assert string value matches _regexp_.
   *
   * @param {RegExp} regexp
   * @api public
   */
            Assertion.prototype.match = function(regexp) {
                this.assert(regexp.exec(this.obj), "expected " + i(this.obj) + " to match " + regexp, "expected " + i(this.obj) + " not to match " + regexp);
                return this;
            };
            /**
   * Assert property "length" exists and has value of _n_.
   *
   * @param {Number} n
   * @api public
   */
            Assertion.prototype.length = function(n) {
                expect(this.obj).to.have.property("length");
                var len = this.obj.length;
                this.assert(n == len, "expected " + i(this.obj) + " to have a length of " + n + " but got " + len, "expected " + i(this.obj) + " to not have a length of " + len);
                return this;
            };
            /**
   * Assert property _name_ exists, with optional _val_.
   *
   * @param {String} name
   * @param {Mixed} val
   * @api public
   */
            Assertion.prototype.property = function(name, val) {
                if (this.flags.own) {
                    this.assert(Object.prototype.hasOwnProperty.call(this.obj, name), "expected " + i(this.obj) + " to have own property " + i(name), "expected " + i(this.obj) + " to not have own property " + i(name));
                    return this;
                }
                if (this.flags.not && undefined !== val) {
                    if (undefined === this.obj[name]) {
                        throw new Error(i(this.obj) + " has no property " + i(name));
                    }
                } else {
                    var hasProp;
                    try {
                        hasProp = name in this.obj;
                    } catch (e) {
                        hasProp = undefined !== this.obj[name];
                    }
                    this.assert(hasProp, "expected " + i(this.obj) + " to have a property " + i(name), "expected " + i(this.obj) + " to not have a property " + i(name));
                }
                if (undefined !== val) {
                    this.assert(val === this.obj[name], "expected " + i(this.obj) + " to have a property " + i(name) + " of " + i(val) + ", but got " + i(this.obj[name]), "expected " + i(this.obj) + " to not have a property " + i(name) + " of " + i(val));
                }
                this.obj = this.obj[name];
                return this;
            };
            /**
   * Assert that the array contains _obj_ or string contains _obj_.
   *
   * @param {Mixed} obj|string
   * @api public
   */
            Assertion.prototype.string = Assertion.prototype.contain = function(obj) {
                if ("string" == typeof this.obj) {
                    this.assert(~this.obj.indexOf(obj), "expected " + i(this.obj) + " to contain " + i(obj), "expected " + i(this.obj) + " to not contain " + i(obj));
                } else {
                    this.assert(~indexOf(this.obj, obj), "expected " + i(this.obj) + " to contain " + i(obj), "expected " + i(this.obj) + " to not contain " + i(obj));
                }
                return this;
            };
            /**
   * Assert exact keys or inclusion of keys by using
   * the `.own` modifier.
   *
   * @param {Array|String ...} keys
   * @api public
   */
            Assertion.prototype.key = Assertion.prototype.keys = function($keys) {
                var str, ok = true;
                $keys = isArray($keys) ? $keys : Array.prototype.slice.call(arguments);
                if (!$keys.length) throw new Error("keys required");
                var actual = keys(this.obj), len = $keys.length;
                // Inclusion
                ok = every($keys, function(key) {
                    return ~indexOf(actual, key);
                });
                // Strict
                if (!this.flags.not && this.flags.only) {
                    ok = ok && $keys.length == actual.length;
                }
                // Key string
                if (len > 1) {
                    $keys = map($keys, function(key) {
                        return i(key);
                    });
                    var last = $keys.pop();
                    str = $keys.join(", ") + ", and " + last;
                } else {
                    str = i($keys[0]);
                }
                // Form
                str = (len > 1 ? "keys " : "key ") + str;
                // Have / include
                str = (!this.flags.only ? "include " : "only have ") + str;
                // Assertion
                this.assert(ok, "expected " + i(this.obj) + " to " + str, "expected " + i(this.obj) + " to not " + str);
                return this;
            };
            /**
   * Function bind implementation.
   */
            function bind(fn, scope) {
                return function() {
                    return fn.apply(scope, arguments);
                };
            }
            /**
   * Array every compatibility
   *
   * @see bit.ly/5Fq1N2
   * @api public
   */
            function every(arr, fn, thisObj) {
                var scope = thisObj || global;
                for (var i = 0, j = arr.length; i < j; ++i) {
                    if (!fn.call(scope, arr[i], i, arr)) {
                        return false;
                    }
                }
                return true;
            }
            /**
   * Array indexOf compatibility.
   *
   * @see bit.ly/a5Dxa2
   * @api public
   */
            function indexOf(arr, o, i) {
                if (Array.prototype.indexOf) {
                    return Array.prototype.indexOf.call(arr, o, i);
                }
                if (arr.length === undefined) {
                    return -1;
                }
                for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0; i < j && arr[i] !== o; i++) ;
                return j <= i ? -1 : i;
            }
            /**
   * Inspects an object.
   *
   * @see taken from node.js `util` module (copyright Joyent, MIT license)
   * @api private
   */
            function i(obj, showHidden, depth) {
                var seen = [];
                function stylize(str) {
                    return str;
                }
                function format(value, recurseTimes) {
                    // Provide a hook for user-specified inspect functions.
                    // Check that value is an object with an inspect function on it
                    if (value && typeof value.inspect === "function" && // Filter out the util module, it's inspect function is special
                    value !== exports && // Also filter out any prototype objects using the circular check.
                    !(value.constructor && value.constructor.prototype === value)) {
                        return value.inspect(recurseTimes);
                    }
                    // Primitive types cannot have properties
                    switch (typeof value) {
                      case "undefined":
                        return stylize("undefined", "undefined");

                      case "string":
                        var simple = "'" + json.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                        return stylize(simple, "string");

                      case "number":
                        return stylize("" + value, "number");

                      case "boolean":
                        return stylize("" + value, "boolean");
                    }
                    // For some reason typeof null is "object", so special case here.
                    if (value === null) {
                        return stylize("null", "null");
                    }
                    // Look up the keys of the object.
                    var visible_keys = keys(value);
                    var $keys = showHidden ? Object.getOwnPropertyNames(value) : visible_keys;
                    // Functions without properties can be shortcutted.
                    if (typeof value === "function" && $keys.length === 0) {
                        if (isRegExp(value)) {
                            return stylize("" + value, "regexp");
                        } else {
                            var name = value.name ? ": " + value.name : "";
                            return stylize("[Function" + name + "]", "special");
                        }
                    }
                    // Dates without properties can be shortcutted
                    if (isDate(value) && $keys.length === 0) {
                        return stylize(value.toUTCString(), "date");
                    }
                    var base, type, braces;
                    // Determine the object type
                    if (isArray(value)) {
                        type = "Array";
                        braces = [ "[", "]" ];
                    } else {
                        type = "Object";
                        braces = [ "{", "}" ];
                    }
                    // Make functions say that they are functions
                    if (typeof value === "function") {
                        var n = value.name ? ": " + value.name : "";
                        base = isRegExp(value) ? " " + value : " [Function" + n + "]";
                    } else {
                        base = "";
                    }
                    // Make dates with properties first say the date
                    if (isDate(value)) {
                        base = " " + value.toUTCString();
                    }
                    if ($keys.length === 0) {
                        return braces[0] + base + braces[1];
                    }
                    if (recurseTimes < 0) {
                        if (isRegExp(value)) {
                            return stylize("" + value, "regexp");
                        } else {
                            return stylize("[Object]", "special");
                        }
                    }
                    seen.push(value);
                    var output = map($keys, function(key) {
                        var name, str;
                        if (value.__lookupGetter__) {
                            if (value.__lookupGetter__(key)) {
                                if (value.__lookupSetter__(key)) {
                                    str = stylize("[Getter/Setter]", "special");
                                } else {
                                    str = stylize("[Getter]", "special");
                                }
                            } else {
                                if (value.__lookupSetter__(key)) {
                                    str = stylize("[Setter]", "special");
                                }
                            }
                        }
                        if (indexOf(visible_keys, key) < 0) {
                            name = "[" + key + "]";
                        }
                        if (!str) {
                            if (indexOf(seen, value[key]) < 0) {
                                if (recurseTimes === null) {
                                    str = format(value[key]);
                                } else {
                                    str = format(value[key], recurseTimes - 1);
                                }
                                if (str.indexOf("\n") > -1) {
                                    if (isArray(value)) {
                                        str = map(str.split("\n"), function(line) {
                                            return "  " + line;
                                        }).join("\n").substr(2);
                                    } else {
                                        str = "\n" + map(str.split("\n"), function(line) {
                                            return "   " + line;
                                        }).join("\n");
                                    }
                                }
                            } else {
                                str = stylize("[Circular]", "special");
                            }
                        }
                        if (typeof name === "undefined") {
                            if (type === "Array" && key.match(/^\d+$/)) {
                                return str;
                            }
                            name = json.stringify("" + key);
                            if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                                name = name.substr(1, name.length - 2);
                                name = stylize(name, "name");
                            } else {
                                name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                                name = stylize(name, "string");
                            }
                        }
                        return name + ": " + str;
                    });
                    seen.pop();
                    var numLinesEst = 0;
                    var length = reduce(output, function(prev, cur) {
                        numLinesEst++;
                        if (indexOf(cur, "\n") >= 0) numLinesEst++;
                        return prev + cur.length + 1;
                    }, 0);
                    if (length > 50) {
                        output = braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
                    } else {
                        output = braces[0] + base + " " + output.join(", ") + " " + braces[1];
                    }
                    return output;
                }
                return format(obj, typeof depth === "undefined" ? 2 : depth);
            }
            function isArray(ar) {
                return Object.prototype.toString.call(ar) == "[object Array]";
            }
            function isRegExp(re) {
                var s = "" + re;
                return re instanceof RegExp || // easy case
                // duck-type for context-switching evalcx case
                typeof re === "function" && re.constructor.name === "RegExp" && re.compile && re.test && re.exec && s.match(/^\/.*\/[gim]{0,3}$/);
            }
            function isDate(d) {
                if (d instanceof Date) return true;
                return false;
            }
            function keys(obj) {
                if (Object.keys) {
                    return Object.keys(obj);
                }
                var keys = [];
                for (var i in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, i)) {
                        keys.push(i);
                    }
                }
                return keys;
            }
            function map(arr, mapper, that) {
                if (Array.prototype.map) {
                    return Array.prototype.map.call(arr, mapper, that);
                }
                var other = new Array(arr.length);
                for (var i = 0, n = arr.length; i < n; i++) if (i in arr) other[i] = mapper.call(that, arr[i], i, arr);
                return other;
            }
            function reduce(arr, fun) {
                if (Array.prototype.reduce) {
                    return Array.prototype.reduce.apply(arr, Array.prototype.slice.call(arguments, 1));
                }
                var len = +this.length;
                if (typeof fun !== "function") throw new TypeError();
                // no value to return if no initial value and an empty array
                if (len === 0 && arguments.length === 1) throw new TypeError();
                var i = 0;
                if (arguments.length >= 2) {
                    var rv = arguments[1];
                } else {
                    do {
                        if (i in this) {
                            rv = this[i++];
                            break;
                        }
                        // if array contains no values, no initial value to return
                        if (++i >= len) throw new TypeError();
                    } while (true);
                }
                for (;i < len; i++) {
                    if (i in this) rv = fun.call(null, rv, this[i], i, this);
                }
                return rv;
            }
            /**
   * Asserts deep equality
   *
   * @see taken from node.js `assert` module (copyright Joyent, MIT license)
   * @api private
   */
            expect.eql = function eql(actual, expected) {
                // 7.1. All identical values are equivalent, as determined by ===.
                if (actual === expected) {
                    return true;
                } else if ("undefined" != typeof Buffer && Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
                    if (actual.length != expected.length) return false;
                    for (var i = 0; i < actual.length; i++) {
                        if (actual[i] !== expected[i]) return false;
                    }
                    return true;
                } else if (actual instanceof Date && expected instanceof Date) {
                    return actual.getTime() === expected.getTime();
                } else if (typeof actual != "object" && typeof expected != "object") {
                    return actual == expected;
                } else {
                    return objEquiv(actual, expected);
                }
            };
            function isUndefinedOrNull(value) {
                return value === null || value === undefined;
            }
            function isArguments(object) {
                return Object.prototype.toString.call(object) == "[object Arguments]";
            }
            function objEquiv(a, b) {
                if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
                // an identical "prototype" property.
                if (a.prototype !== b.prototype) return false;
                //~~~I've managed to break Object.keys through screwy arguments passing.
                //   Converting to array solves the problem.
                if (isArguments(a)) {
                    if (!isArguments(b)) {
                        return false;
                    }
                    a = pSlice.call(a);
                    b = pSlice.call(b);
                    return expect.eql(a, b);
                }
                try {
                    var ka = keys(a), kb = keys(b), key, i;
                } catch (e) {
                    //happens when one is a string literal and the other isn't
                    return false;
                }
                // having the same number of owned properties (keys incorporates hasOwnProperty)
                if (ka.length != kb.length) return false;
                //the same set of keys (although not necessarily the same order),
                ka.sort();
                kb.sort();
                //~~~cheap key test
                for (i = ka.length - 1; i >= 0; i--) {
                    if (ka[i] != kb[i]) return false;
                }
                //equivalent values for every corresponding key, and
                //~~~possibly expensive deep test
                for (i = ka.length - 1; i >= 0; i--) {
                    key = ka[i];
                    if (!expect.eql(a[key], b[key])) return false;
                }
                return true;
            }
            var json = function() {
                "use strict";
                if ("object" == typeof JSON && JSON.parse && JSON.stringify) {
                    return {
                        parse: nativeJSON.parse,
                        stringify: nativeJSON.stringify
                    };
                }
                var JSON = {};
                function f(n) {
                    // Format integers to have at least two digits.
                    return n < 10 ? "0" + n : n;
                }
                function date(d, key) {
                    return isFinite(d.valueOf()) ? d.getUTCFullYear() + "-" + f(d.getUTCMonth() + 1) + "-" + f(d.getUTCDate()) + "T" + f(d.getUTCHours()) + ":" + f(d.getUTCMinutes()) + ":" + f(d.getUTCSeconds()) + "Z" : null;
                }
                var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
                    // table of character substitutions
                    "\b": "\\b",
                    "	": "\\t",
                    "\n": "\\n",
                    "\f": "\\f",
                    "\r": "\\r",
                    '"': '\\"',
                    "\\": "\\\\"
                }, rep;
                function quote(string) {
                    // If the string contains no control characters, no quote characters, and no
                    // backslash characters, then we can safely slap some quotes around it.
                    // Otherwise we must also replace the offending characters with safe escape
                    // sequences.
                    escapable.lastIndex = 0;
                    return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
                        var c = meta[a];
                        return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                    }) + '"' : '"' + string + '"';
                }
                function str(key, holder) {
                    // Produce a string from holder[key].
                    var i, // The loop counter.
                    k, // The member key.
                    v, // The member value.
                    length, mind = gap, partial, value = holder[key];
                    // If the value has a toJSON method, call it to obtain a replacement value.
                    if (value instanceof Date) {
                        value = date(key);
                    }
                    // If we were called with a replacer function, then call the replacer to
                    // obtain a replacement value.
                    if (typeof rep === "function") {
                        value = rep.call(holder, key, value);
                    }
                    // What happens next depends on the value's type.
                    switch (typeof value) {
                      case "string":
                        return quote(value);

                      case "number":
                        // JSON numbers must be finite. Encode non-finite numbers as null.
                        return isFinite(value) ? String(value) : "null";

                      case "boolean":
                      case "null":
                        // If the value is a boolean or null, convert it to a string. Note:
                        // typeof null does not produce 'null'. The case is included here in
                        // the remote chance that this gets fixed someday.
                        return String(value);

                      // If the type is 'object', we might be dealing with an object or an array or
                        // null.
                        case "object":
                        // Due to a specification blunder in ECMAScript, typeof null is 'object',
                        // so watch out for that case.
                        if (!value) {
                            return "null";
                        }
                        // Make an array to hold the partial results of stringifying this object value.
                        gap += indent;
                        partial = [];
                        // Is the value an array?
                        if (Object.prototype.toString.apply(value) === "[object Array]") {
                            // The value is an array. Stringify every element. Use null as a placeholder
                            // for non-JSON values.
                            length = value.length;
                            for (i = 0; i < length; i += 1) {
                                partial[i] = str(i, value) || "null";
                            }
                            // Join all of the elements together, separated with commas, and wrap them in
                            // brackets.
                            v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
                            gap = mind;
                            return v;
                        }
                        // If the replacer is an array, use it to select the members to be stringified.
                        if (rep && typeof rep === "object") {
                            length = rep.length;
                            for (i = 0; i < length; i += 1) {
                                if (typeof rep[i] === "string") {
                                    k = rep[i];
                                    v = str(k, value);
                                    if (v) {
                                        partial.push(quote(k) + (gap ? ": " : ":") + v);
                                    }
                                }
                            }
                        } else {
                            // Otherwise, iterate through all of the keys in the object.
                            for (k in value) {
                                if (Object.prototype.hasOwnProperty.call(value, k)) {
                                    v = str(k, value);
                                    if (v) {
                                        partial.push(quote(k) + (gap ? ": " : ":") + v);
                                    }
                                }
                            }
                        }
                        // Join all of the member texts together, separated with commas,
                        // and wrap them in braces.
                        v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
                        gap = mind;
                        return v;
                    }
                }
                // If the JSON object does not yet have a stringify method, give it one.
                JSON.stringify = function(value, replacer, space) {
                    // The stringify method takes a value and an optional replacer, and an optional
                    // space parameter, and returns a JSON text. The replacer can be a function
                    // that can replace values, or an array of strings that will select the keys.
                    // A default replacer method can be provided. Use of the space parameter can
                    // produce text that is more easily readable.
                    var i;
                    gap = "";
                    indent = "";
                    // If the space parameter is a number, make an indent string containing that
                    // many spaces.
                    if (typeof space === "number") {
                        for (i = 0; i < space; i += 1) {
                            indent += " ";
                        }
                    } else if (typeof space === "string") {
                        indent = space;
                    }
                    // If there is a replacer, it must be a function or an array.
                    // Otherwise, throw an error.
                    rep = replacer;
                    if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
                        throw new Error("JSON.stringify");
                    }
                    // Make a fake root object containing our value under the key of ''.
                    // Return the result of stringifying the value.
                    return str("", {
                        "": value
                    });
                };
                // If the JSON object does not yet have a parse method, give it one.
                JSON.parse = function(text, reviver) {
                    // The parse method takes a text and an optional reviver function, and returns
                    // a JavaScript value if the text is a valid JSON text.
                    var j;
                    function walk(holder, key) {
                        // The walk method is used to recursively walk the resulting structure so
                        // that modifications can be made.
                        var k, v, value = holder[key];
                        if (value && typeof value === "object") {
                            for (k in value) {
                                if (Object.prototype.hasOwnProperty.call(value, k)) {
                                    v = walk(value, k);
                                    if (v !== undefined) {
                                        value[k] = v;
                                    } else {
                                        delete value[k];
                                    }
                                }
                            }
                        }
                        return reviver.call(holder, key, value);
                    }
                    // Parsing happens in four stages. In the first stage, we replace certain
                    // Unicode characters with escape sequences. JavaScript handles many characters
                    // incorrectly, either silently deleting them, or treating them as line endings.
                    text = String(text);
                    cx.lastIndex = 0;
                    if (cx.test(text)) {
                        text = text.replace(cx, function(a) {
                            return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                        });
                    }
                    // In the second stage, we run the text against regular expressions that look
                    // for non-JSON patterns. We are especially concerned with '()' and 'new'
                    // because they can cause invocation, and '=' because it can cause mutation.
                    // But just to be safe, we want to reject all unexpected forms.
                    // We split the second stage into 4 regexp operations in order to work around
                    // crippling inefficiencies in IE's and Safari's regexp engines. First we
                    // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
                    // replace all simple value tokens with ']' characters. Third, we delete all
                    // open brackets that follow a colon or comma or that begin the text. Finally,
                    // we look to see that the remaining characters are only whitespace or ']' or
                    // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.
                    if (/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) {
                        // In the third stage we use the eval function to compile the text into a
                        // JavaScript structure. The '{' operator is subject to a syntactic ambiguity
                        // in JavaScript: it can begin a block or an object literal. We wrap the text
                        // in parens to eliminate the ambiguity.
                        j = eval("(" + text + ")");
                        // In the optional fourth stage, we recursively walk the new structure, passing
                        // each name/value pair to a reviver function for possible transformation.
                        return typeof reviver === "function" ? walk({
                            "": j
                        }, "") : j;
                    }
                    // If the text is not JSON parseable, then a SyntaxError is thrown.
                    throw new SyntaxError("JSON.parse");
                };
                return JSON;
            }();
            if ("undefined" != typeof window) {
                window.expect = module.exports;
            }
        })(this, "undefined" != typeof module ? module : {}, "undefined" != typeof exports ? exports : {});
    },
    "3": function(require, module, exports, global) {
        /*
array
*/
                "use strict";

        var array = require("4")["array"];

        var proto = Array.prototype;

        array.implement({
            concat: proto.concat,
            join: proto.join,
            pop: proto.pop,
            push: proto.push,
            reverse: proto.reverse,
            shift: proto.shift,
            slice: proto.slice,
            sort: proto.sort,
            splice: proto.splice,
            toString: proto.toString,
            unshift: proto.unshift
        });

        array.extend({
            every: require("d"),
            filter: require("e"),
            forEach: require("f"),
            indexOf: require("g"),
            lastIndexOf: require("h"),
            map: require("i"),
            remove: require("j"),
            some: require("k"),
            unset: require("l")
        });

        module.exports = array;
    },
    "4": function(require, module, exports, global) {
        /*
shell
*/
                "use strict";

        var prime = require("5"), type = require("c"), forIn = require("7");

        var slice = Array.prototype.slice, push = Array.prototype.push;

        var ghost = prime({
            constructor: function ghost(self) {
                this.valueOf = function() {
                    return self;
                };
                this.toString = function() {
                    return self + "";
                };
                this.is = function(object) {
                    return self === object;
                };
                this.get = function(index) {
                    return self[index];
                };
                this.set = function(index, value) {
                    self[index] = value;
                    return self;
                };
            }
        });

        var shell = function(self) {
            if (self == null || self instanceof ghost) return self;
            var g = shell[type(self)];
            return g ? new g(self) : self;
        };

        var register = function() {
            var g = prime({
                inherits: ghost
            });
            var s = prime(function(self) {
                return new g(self);
            });
            s.extend = function(object) {
                var self = this;
                forIn(object, function(method, key) {
                    this[key] = method;
                    this.prototype[key] = function() {
                        if (!arguments.length) return method.call(self, this);
                        var args = [ this ];
                        push.apply(args, arguments);
                        return method.apply(self, args);
                    };
                    g.prototype[key] = function() {
                        var value = this.valueOf();
                        if (!arguments.length) return method.call(self, value);
                        var args = [ value ];
                        push.apply(args, arguments);
                        return method.apply(self, args);
                    };
                }, this);
                return this;
            };
            s.implement = function(object) {
                forIn(object, function(method, key) {
                    this[key] = function(self) {
                        return arguments.length > 1 ? method.apply(self, slice.call(arguments, 1)) : method.call(self);
                    };
                    g.prototype[key] = function() {
                        return shell(method.apply(this.valueOf(), arguments));
                    };
                    this.prototype[key] = method;
                }, this);
                return this;
            };
            return s;
        };

        for (var types = [ "string", "number", "array", "object", "date", "function", "regexp" ], i = types.length; i--; ) shell[types[i]] = register();

        module.exports = shell;
    },
    "5": function(require, module, exports, global) {
        /*
prime
 - prototypal inheritance
*/
                "use strict";

        var hasOwn = require("6"), forIn = require("7"), mixIn = require("8"), filter = require("a"), create = require("b"), type = require("c");

        var defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

        try {
            defineProperty({}, "~", {});
            getOwnPropertyDescriptor({}, "~");
        } catch (e) {
            defineProperty = null;
            getOwnPropertyDescriptor = null;
        }

        var define = function(value, key, from) {
            defineProperty(this, key, getOwnPropertyDescriptor(from, key) || {
                writable: true,
                enumerable: true,
                configurable: true,
                value: value
            });
        };

        var copy = function(value, key) {
            this[key] = value;
        };

        var implement = function(proto) {
            forIn(proto, defineProperty ? define : copy, this.prototype);
            return this;
        };

        var verbs = /^constructor|inherits|mixin$/;

        var prime = function(proto) {
            if (type(proto) === "function") proto = {
                constructor: proto
            };
            var superprime = proto.inherits;
            // if our nice proto object has no own constructor property
            // then we proceed using a ghosting constructor that all it does is
            // call the parent's constructor if it has a superprime, else an empty constructor
            // proto.constructor becomes the effective constructor
            var constructor = hasOwn(proto, "constructor") ? proto.constructor : superprime ? function() {
                return superprime.apply(this, arguments);
            } : function() {};
            if (superprime) {
                mixIn(constructor, superprime);
                var superproto = superprime.prototype;
                // inherit from superprime
                var cproto = constructor.prototype = create(superproto);
                // setting constructor.parent to superprime.prototype
                // because it's the shortest possible absolute reference
                constructor.parent = superproto;
                cproto.constructor = constructor;
            }
            if (!constructor.implement) constructor.implement = implement;
            var mixins = proto.mixin;
            if (mixins) {
                if (type(mixins) !== "array") mixins = [ mixins ];
                for (var i = 0; i < mixins.length; i++) constructor.implement(create(mixins[i].prototype));
            }
            // implement proto and return constructor
            return constructor.implement(filter(proto, function(value, key) {
                return !key.match(verbs);
            }));
        };

        module.exports = prime;
    },
    "6": function(require, module, exports, global) {
        /*
object:hasOwn
*/
                "use strict";

        var hasOwnProperty = Object.hasOwnProperty;

        var hasOwn = function(self, key) {
            return hasOwnProperty.call(self, key);
        };

        module.exports = hasOwn;
    },
    "7": function(require, module, exports, global) {
        /*
object:forIn
*/
                "use strict";

        var has = require("6");

        var forIn = function(self, method, context) {
            for (var key in self) if (method.call(context, self[key], key, self) === false) break;
            return self;
        };

        if (!{
            valueOf: 0
        }.propertyIsEnumerable("valueOf")) {
            // fix for stupid IE enumeration bug
            var buggy = "constructor,toString,valueOf,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString".split(",");
            var proto = Object.prototype;
            forIn = function(self, method, context) {
                for (var key in self) if (method.call(context, self[key], key, self) === false) return self;
                for (var i = 0; key = buggy[i]; i++) {
                    var value = self[key];
                    if ((value !== proto[key] || has(self, key)) && method.call(context, value, key, self) === false) break;
                }
                return self;
            };
        }

        module.exports = forIn;
    },
    "8": function(require, module, exports, global) {
        /*
object:mixIn
*/
                "use strict";

        var forOwn = require("9");

        var copy = function(value, key) {
            this[key] = value;
        };

        var mixIn = function(self) {
            for (var i = 1, l = arguments.length; i < l; i++) forOwn(arguments[i], copy, self);
            return self;
        };

        module.exports = mixIn;
    },
    "9": function(require, module, exports, global) {
        /*
object:forOwn
*/
                "use strict";

        var forIn = require("7"), hasOwn = require("6");

        var forOwn = function(self, method, context) {
            forIn(self, function(value, key) {
                if (hasOwn(self, key)) return method.call(context, value, key, self);
            });
            return self;
        };

        module.exports = forOwn;
    },
    a: function(require, module, exports, global) {
        /*
object:filter
*/
                "use strict";

        var forIn = require("7");

        var filter = function(self, method, context) {
            var results = {};
            forIn(self, function(value, key) {
                if (method.call(context, value, key, self)) results[key] = value;
            });
            return results;
        };

        module.exports = filter;
    },
    b: function(require, module, exports, global) {
        /*
object:create
*/
                "use strict";

        var create = function(self) {
            var constructor = function() {};
            constructor.prototype = self;
            return new constructor();
        };

        module.exports = create;
    },
    c: function(require, module, exports, global) {
        /*
type
*/
                "use strict";

        var toString = Object.prototype.toString, types = /number|object|array|string|function|date|regexp|boolean/;

        var type = function(object) {
            if (object == null) return "null";
            var string = toString.call(object).slice(8, -1).toLowerCase();
            if (string === "number" && isNaN(object)) return "null";
            if (types.test(string)) return string;
            return "object";
        };

        module.exports = type;
    },
    d: function(require, module, exports, global) {
        /*
array:every
*/
                "use strict";

        var every = function(self, method, context) {
            for (var i = 0, l = self.length >>> 0; i < l; i++) {
                if (!method.call(context, self[i], i, self)) return false;
            }
            return true;
        };

        module.exports = every;
    },
    e: function(require, module, exports, global) {
        /*
array:filter
*/
                "use strict";

        var filter = function(self, method, context) {
            var results = [];
            for (var i = 0, l = self.length >>> 0; i < l; i++) {
                var value = self[i];
                if (method.call(context, value, i, self)) results.push(value);
            }
            return results;
        };

        module.exports = filter;
    },
    f: function(require, module, exports, global) {
        /*
array:forEach
*/
                "use strict";

        var forEach = function(self, method, context) {
            for (var i = 0, l = self.length >>> 0; i < l; i++) {
                if (method.call(context, self[i], i, self) === false) break;
            }
            return self;
        };

        module.exports = forEach;
    },
    g: function(require, module, exports, global) {
        /*
array:indexOf
*/
                "use strict";

        var indexOf = function(self, item, from) {
            for (var l = self.length >>> 0, i = from < 0 ? Math.max(0, l + from) : from || 0; i < l; i++) {
                if (self[i] === item) return i;
            }
            return -1;
        };

        module.exports = indexOf;
    },
    h: function(require, module, exports, global) {
        /*
array:lastIndexOf
*/
                "use strict";

        module.exports = function() {};
    },
    i: function(require, module, exports, global) {
        /*
array:map
*/
                "use strict";

        var map = function(self, method, context) {
            var length = self.length >>> 0, results = Array(length);
            for (var i = 0, l = length; i < l; i++) {
                results[i] = method.call(context, self[i], i, self);
            }
            return results;
        };

        module.exports = map;
    },
    j: function(require, module, exports, global) {
        /*
array:remove
*/
                "use strict";

        var splice = Array.prototype.splice;

        var indexOf = require("g");

        var remove = function(self, item) {
            var io = indexOf(self, item);
            if (io !== -1) splice.call(self, io, 1);
            return io;
        };

        module.exports = remove;
    },
    k: function(require, module, exports, global) {
        /*
array:some
*/
                "use strict";

        var some = function(self, method, context) {
            for (var i = 0, l = self.length >>> 0; i < l; i++) {
                if (method.call(context, self[i], i, self)) return true;
            }
            return false;
        };

        module.exports = some;
    },
    l: function(require, module, exports, global) {
        /*
array:unset
*/
                "use strict";

        var splice = Array.prototype.splice;

        var unset = function(self, index) {
            var split = splice.call(self, index, 1);
            return split.length ? split[0] : null;
        };

        module.exports = unset;
    },
    m: function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var date = require("n");

        describe("es5/date", function() {
            describe("Date.now", function() {
                it("should return the current date timestamp", function() {
                    expect(Math.round(new Date().getTime() / 1e3)).to.eql(Math.round(date.now() / 1e3));
                });
            });
        });
    },
    n: function(require, module, exports, global) {
        /*
date
*/
                "use strict";

        var date = require("4")["date"];

        var names = [ "getDate", "getDay", "getFullYear", "getHours", "getMilliseconds", "getMinutes", "getMonth", "getSeconds", "getTime", "getTimezoneOffset", "getUTCDate", "getUTCDay", "getUTCFullYear", "getUTCHours", "getUTCMilliseconds", "getUTCMinutes", "getUTCMonth", "getUTCSeconds", "setDate", "setFullYear", "setHours", "setMilliseconds", "setMinutes", "setMonth", "setSeconds", "setTime", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "toDateString", "toLocaleDateString", "toLocaleString", "toLocaleTimeString", "toString", "toTimeString", "toUTCString", "valueOf" ];

        for (var proto = Date.prototype, methods = {}, i = 0, name; name = names[i++]; ) methods[name] = proto[name];

        date.implement(methods);

        date.now = require("o");

        module.exports = date;
    },
    o: function(require, module, exports, global) {
        /*
date:now
*/
                "use strict";

        var now = Date.now || function() {
            return new Date().getTime();
        };

        module.exports = now;
    },
    p: function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var fn = require("q");

        describe("function", function() {
            it("should implement .apply", function() {
                var context = {};
                fn.apply(function(a, b) {
                    expect(this).to.be(context);
                    expect(a).to.be(1);
                    expect(b).to.be(2);
                }, context, [ 1, 2 ]);
            });
            it("should implement .call", function() {
                var context = {};
                fn.call(function(a, b) {
                    expect(this).to.be(context);
                    expect(a).to.be(1);
                    expect(b).to.be(2);
                }, context, 1, 2);
            });
        });
    },
    q: function(require, module, exports, global) {
        /*
function
*/
                "use strict";

        var function_ = require("4")["function"];

        var proto = Function.prototype;

        function_.implement({
            apply: proto.apply,
            call: proto.call,
            toString: proto.toString
        });

        function_.extend({
            bind: require("r")
        });

        module.exports = function_;
    },
    r: function(require, module, exports, global) {
        /*
function:bind
*/
                "use strict";

        var slice = Array.prototype.slice;

        var bind = function(self, context) {
            if (arguments.length < 3) return function() {
                return self.apply(context, arguments);
            };
            var args = slice.call(arguments, 2);
            return function() {
                return self.apply(context, arguments.length ? args.concat(slice.call(arguments)) : args);
            };
        };

        module.exports = bind;
    },
    s: function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var number = require("t");

        describe("number", function() {
            it("should have implemented Number methods", function() {
                expect(number.toExponential(1e3)).to.equal("1e+3");
                expect(number.toFixed(3.14159, 2)).to.equal("3.14");
                expect(number.toPrecision(3.14159, 2)).to.equal("3.1");
            });
        });
    },
    t: function(require, module, exports, global) {
        /*
number
 - number es5 shell
*/
                "use strict";

        var number = require("4")["number"];

        var proto = Number.prototype;

        number.implement({
            toExponential: proto.toExponential,
            toFixed: proto.toFixed,
            toPrecision: proto.toPrecision
        });

        number.extend({
            limit: require("u"),
            random: require("v"),
            round: require("w"),
            times: require("x")
        });

        module.exports = number;
    },
    u: function(require, module, exports, global) {
        /*
number:limit
*/
                "use strict";

        var limit = function(self, min, max) {
            return Math.min(max, Math.max(min, self));
        };

        module.exports = limit;
    },
    v: function(require, module, exports, global) {
        /*
number:random
*/
                "use strict";

        var random = function(self, max) {
            return Math.floor(Math.random() * (max - self + 1) + self);
        };

        module.exports = random;
    },
    w: function(require, module, exports, global) {
        /*
number:round
*/
                "use strict";

        var round = function(self, precision) {
            precision = Math.pow(10, precision || 0).toFixed(precision < 0 ? -precision : 0);
            return Math.round(self * precision) / precision;
        };

        module.exports = round;
    },
    x: function(require, module, exports, global) {
        /*
number:times
*/
                "use strict";

        var times = function(self, method, context) {
            for (var i = 0; i < self; i++) {
                if (method.call(context, i, null, self) === false) break;
            }
            return self;
        };

        module.exports = times;
    },
    y: function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var object = require("z");

        describe("es5/object", function() {
            it("should have exported a value", function() {
                expect(object != null).to.be.ok();
            });
            it("should implement existing methods in the shell", function() {
                expect(object.hasOwnProperty).to.be.ok();
                expect(object.hasOwnProperty != Object.prototype.hasOwnProperty).to.be.ok();
                expect(object.toString([])).to.be("[object Array]");
            });
        });
    },
    z: function(require, module, exports, global) {
        /*
object
*/
                "use strict";

        var object = require("4")["object"];

        var proto = Object.prototype;

        object.implement({
            hasOwnProperty: proto.hasOwnProperty,
            toString: proto.toString,
            valueOf: proto.valueOf
        });

        object.extend({
            count: require("10"),
            create: require("b"),
            every: require("11"),
            filter: require("a"),
            forIn: require("7"),
            forOwn: require("9"),
            hasOwn: require("6"),
            indexOf: require("12"),
            keys: require("13"),
            map: require("14"),
            mixIn: require("8"),
            remove: require("15"),
            some: require("16"),
            unset: require("17"),
            values: require("18")
        });

        module.exports = object;
    },
    "10": function(require, module, exports, global) {
        /*
object:count
*/
                "use strict";

        var forIn = require("7");

        var count = function(self) {
            var length = 0;
            forIn(self, function() {
                length++;
            });
            return length;
        };

        module.exports = count;
    },
    "11": function(require, module, exports, global) {
        /*
object:every
*/
                "use strict";

        var forIn = require("7");

        var every = function(self, method, context) {
            var every = true;
            forIn(self, function(value, key) {
                if (!method.call(context, value, key, self)) return every = false;
            });
            return every;
        };

        module.exports = every;
    },
    "12": function(require, module, exports, global) {
        /*
object:indexOf
*/
                "use strict";

        var forIn = require("7");

        var indexOf = function(self, value) {
            var key = null;
            forIn(self, function(match, k) {
                if (value === match) {
                    key = k;
                    return false;
                }
            });
            return key;
        };

        module.exports = indexOf;
    },
    "13": function(require, module, exports, global) {
        /*
object:keys
*/
                "use strict";

        var forIn = require("7");

        var keys = function(self) {
            var keys = [];
            forIn(self, function(value, key) {
                keys.push(key);
            });
            return keys;
        };

        module.exports = keys;
    },
    "14": function(require, module, exports, global) {
        /*
object:map
*/
                "use strict";

        var forIn = require("7");

        var map = function(self, method, context) {
            var results = {};
            forIn(self, function(value, key) {
                results[key] = method.call(context, value, key, self);
            });
            return results;
        };

        module.exports = map;
    },
    "15": function(require, module, exports, global) {
        /*
object:remove
*/
                "use strict";

        var forIn = require("7");

        var remove = function(self, item) {
            var ko = null;
            forIn(self, function(value, key) {
                if (value === item) return !delete self[ko = key];
            });
            return ko;
        };

        module.exports = remove;
    },
    "16": function(require, module, exports, global) {
        /*
object:some
*/
                "use strict";

        var forIn = require("7");

        var some = function(self, method, context) {
            var some = false;
            forIn(self, function(value, key) {
                if (!some && method.call(context, value, key, self)) return !(some = true);
            });
            return some;
        };

        module.exports = some;
    },
    "17": function(require, module, exports, global) {
        /*
object:unset
*/
                "use strict";

        var forIn = require("7");

        var unset = function(self, key) {
            var value;
            if (key in self) {
                value = self[key];
                delete self[key];
            }
            return value;
        };

        module.exports = unset;
    },
    "18": function(require, module, exports, global) {
        /*
object:values
*/
                "use strict";

        var forIn = require("7");

        var values = function(self) {
            var values = [];
            forIn(self, function(value, key) {
                values.push(value);
            });
            return values;
        };

        module.exports = values;
    },
    "19": function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var regexp = require("1a");

        describe("regexp", function() {
            it("should implement native regexp methods", function() {
                expect(regexp.test(/a/, "a")).to.be.ok();
                expect(regexp.exec(/a/, "a").join()).to.eql("a");
            });
        });
    },
    "1a": function(require, module, exports, global) {
        /*
regexp
*/
                "use strict";

        var regexp = require("4")["regexp"];

        var proto = RegExp.prototype;

        regexp.implement({
            exec: proto.exec,
            test: proto.test,
            toString: proto.toString
        });

        module.exports = regexp;
    },
    "1b": function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var string = require("1c");

        describe("string", function() {
            describe("trim", function() {
                it("should trim left and right whitespace from the string", function() {
                    expect(string.trim("  i like cookies  ")).to.equal("i like cookies");
                    expect(string.trim("  i  	like  cookies  ")).to.equal("i  	like  cookies");
                });
                it("should return the trimmed value of the returned value of the toString method", function() {
                    expect(string.trim({
                        toString: function() {
                            return "  i like cookies  ";
                        }
                    })).to.equal("i like cookies");
                });
            });
            it("should implement native string methods", function() {
                expect(string.charCodeAt(";", 0)).to.be(59);
                expect(string.toUpperCase("Mannschaft")).to.equal("MANNSCHAFT");
            });
        });
    },
    "1c": function(require, module, exports, global) {
        /*
string
*/
                "use strict";

        var string = require("4")["string"];

        var proto = String.prototype;

        string.implement({
            charAt: proto.charAt,
            charCodeAt: proto.charCodeAt,
            concat: proto.concat,
            indexOf: proto.indexOf,
            lastIndexOf: proto.lastIndexOf,
            match: proto.match,
            replace: proto.replace,
            search: proto.search,
            slice: proto.slice,
            split: proto.split,
            substr: proto.substr,
            substring: proto.substring,
            toLowerCase: proto.toLowerCase,
            toUpperCase: proto.toUpperCase,
            toString: proto.toString,
            valueOf: proto.valueOf
        });

        string.extend({
            camelize: require("1d"),
            capitalize: require("1e"),
            clean: require("1f"),
            escape: require("1h"),
            hyphenate: require("1i"),
            trim: require("1g")
        });

        module.exports = string;
    },
    "1d": function(require, module, exports, global) {
        /*
string:camelize
*/
                "use strict";

        var camelize = function(self) {
            return (self + "").replace(/-\D/g, function(match) {
                return match.charAt(1).toUpperCase();
            });
        };

        module.exports = camelize;
    },
    "1e": function(require, module, exports, global) {
        /*
string:capitalize
*/
                "use strict";

        var capitalize = function(self) {
            return (self + "").replace(/\b[a-z]/g, function(match) {
                return match.toUpperCase();
            });
        };

        module.exports = capitalize;
    },
    "1f": function(require, module, exports, global) {
        /*
string:clean
*/
                "use strict";

        var trim = require("1g");

        var clean = function(self) {
            return trim((self + "").replace(/\s+/g, " "));
        };

        module.exports = clean;
    },
    "1g": function(require, module, exports, global) {
        /*
string:trim
*/
                "use strict";

        var trim = function(self) {
            return (self + "").replace(/^\s+|\s+$/g, "");
        };

        module.exports = trim;
    },
    "1h": function(require, module, exports, global) {
        /*
string:escape
*/
                "use strict";

        var escape = function(self) {
            return (self + "").replace(/([-.*+?^${}()|[\]\/\\])/g, "\\$1");
        };

        module.exports = escape;
    },
    "1i": function(require, module, exports, global) {
        /*
string:hyphenate
*/
                "use strict";

        var hyphenate = function(self) {
            return (self + "").replace(/[A-Z]/g, function(match) {
                return "-" + match.toLowerCase();
            });
        };

        module.exports = hyphenate;
    },
    "1j": function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var prime = require("5");

        var forIn = require("7");

        describe("prime.each", function() {
            var obj = {
                a: "a",
                toString: function() {
                    return "toString";
                },
                valueOf: function() {
                    return "valueOf";
                }
            };
            var keys = [];
            var values = [];
            var objects = [];
            var thisObjects = [];
            var context = {
                b: "b"
            };
            forIn(obj, function(value, key, object) {
                values.push(value);
                keys.push(key);
                objects.push(object);
                thisObjects.push(this);
            }, context);
            it("should iterate over all object members", function() {
                expect(keys).to.eql([ "a", "toString", "valueOf" ]);
                expect(values.length).to.be(3);
                expect(values[0]).to.be(obj.a);
                expect(values[1]).to.be(obj.toString);
                expect(values[2]).to.be(obj.valueOf);
            });
            it("should pass object as the third argument", function() {
                expect(objects.length).to.be(3);
                expect(objects[0]).to.be(obj);
                expect(objects[1]).to.be(obj);
                expect(objects[2]).to.be(obj);
            });
            it("should called with the object as context", function() {
                expect(thisObjects.length).to.be(3);
                expect(thisObjects[0]).to.be(context);
                expect(thisObjects[1]).to.be(context);
                expect(thisObjects[2]).to.be(context);
            });
        });
    },
    "1k": function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var prime = require("5");

        var Animal = prime({
            initialized: false,
            constructor: function(name, sound) {
                this.name = name;
                this.sound = sound || "";
                this.initialized = true;
            },
            eat: function() {
                return "animal:eat:" + this.name;
            },
            say: function() {
                return "animal:say:" + this.name;
            }
        });

        var Cat = prime({
            inherits: Animal,
            ferocious: false,
            constructor: function(name, sound) {
                Cat.parent.constructor.call(this, name, sound || "miao");
            },
            eat: function() {
                return "cat:eat:" + this.name;
            },
            play: function() {
                return "cat:play:" + this.name;
            }
        });

        var Lion = prime({
            inherits: Cat,
            ferocious: true,
            constructor: function(name) {
                Lion.parent.constructor.call(this, name, "rarr");
            },
            eat: function() {
                return "lion:eat:" + this.name;
            }
        });

        var Actions = prime({
            jump: function() {
                return "actions:jump:" + this.name;
            },
            sleep: function() {
                return "actions:sleep:" + this.name;
            }
        });

        var Attributes = prime({
            color: function() {
                return "attributes:color:" + this.name;
            },
            size: function() {
                return "attributes:size:" + this.name;
            }
        });

        var One = prime({});

        var Two = prime({
            inherits: One,
            constructor: function() {
                this.id = "TWO";
            }
        });

        var Three = prime({
            inherits: Two
        });

        describe("prime constructors", function() {
            it("should have the correct constructor", function() {
                var one = new One();
                expect(one.constructor).to.be(One);
                var two = new Two();
                expect(two.constructor).to.be(Two);
                var three = new Three();
                expect(three.constructor).to.be(Three);
            });
            it("should call the parent constructor, even when not explicitly set", function() {
                var one = new One();
                expect(one.id).to.be(undefined);
                var two = new Two();
                expect(two.id).to.be("TWO");
                var three = new Three();
                expect(three.id).to.be("TWO");
                var actual = one.constructor.toString().replace(/\s+/g, "");
                var expected = function() {}.toString().replace(/\s+/g, "");
                expect(actual).to.be(expected);
                expect(Three.prototype.constructor).to.be.a("function");
            });
        });

        describe("prime creation", function() {
            it("should call the constructor upon instantiation", function() {
                var animal = new Animal("lamina");
                expect(animal.name).to.be("lamina");
                expect(animal.initialized).to.be.ok();
                expect(animal.say()).to.be("animal:say:lamina");
            });
            it("should use 'inherits' property to extend another prime", function() {
                var cat = new Cat("fluffy");
                expect(cat.name).to.be("fluffy");
                expect(cat.sound).to.be("miao");
                expect(cat.ferocious).to.eql(false);
                expect(cat.say()).to.be("animal:say:fluffy");
                expect(cat.eat()).to.be("cat:eat:fluffy");
                expect(cat.play()).to.be("cat:play:fluffy");
            });
            it("should use 'inherits' property to extend an extended prime", function() {
                var leo = new Lion("leo");
                expect(leo.name).to.be("leo");
                expect(leo.sound).to.be("rarr");
                expect(leo.ferocious).to.be.ok();
                expect(leo.say()).to.be("animal:say:leo");
                expect(leo.eat()).to.be("lion:eat:leo");
                expect(leo.play()).to.be("cat:play:leo");
            });
            // it("should implement another prime", function(){
            //     var Dog = prime({mixin: Animal})
            //
            //     var rover = new Dog('rover');
            //     expect(rover.name).to.be('rover');
            //     expect(rover.initialized).to.be.ok();
            //     expect(rover.eat()).to.be('animal:eat:rover');
            // });
            //
            // it("should use 'Implements' property to implement any number of primes", function(){
            //     var Dog = prime({
            //         inherit: Animal,
            //         mixin: [Actions, Attributes]
            //     });
            //
            //     var rover = new Dog('rover');
            //     expect(rover.initialized).to.be.ok();
            //     expect(rover.eat()).to.be('animal:eat:rover');
            //     expect(rover.say()).to.be('animal:say:rover');
            //     expect(rover.jump()).to.be('actions:jump:rover');
            //     expect(rover.sleep()).to.be('actions:sleep:rover');
            //     expect(rover.size()).to.be('attributes:size:rover');
            //     expect(rover.color()).to.be('attributes:color:rover');
            // });
            it("should alter the prime's prototype when implementing new methods", function() {
                var Dog = prime({
                    inherits: Animal
                });
                var rover = new Dog("rover");
                Dog.implement({
                    jump: function() {
                        return "dog:jump:" + this.name;
                    }
                });
                var spot = new Dog("spot");
                expect(spot.jump()).to.be("dog:jump:spot");
                expect(rover.jump()).to.be("dog:jump:rover");
            });
            it("should alter the prime's prototype when implementing new methods into the super prime", function() {
                var Dog = prime({
                    inherits: Animal
                });
                var rover = new Dog("rover");
                Animal.implement({
                    jump: function() {
                        return "animal:jump:" + this.name;
                    }
                });
                var spot = new Dog("spot");
                expect(spot.jump()).to.be("animal:jump:spot");
                expect(rover.jump()).to.be("animal:jump:rover");
            });
            it("should alter the prime's prototype when overwriting methods in the super prime", function() {
                var Dog = prime({
                    inherits: Animal
                });
                var rover = new Dog("rover");
                expect(rover.say()).to.be("animal:say:rover");
                Animal.implement({
                    say: function() {
                        return "NEW:animal:say:" + this.name;
                    }
                });
                var spot = new Dog("spot");
                expect(spot.say()).to.be("NEW:animal:say:spot");
                expect(rover.say()).to.be("NEW:animal:say:rover");
            });
        });

        describe("prime::implement", function() {
            it("should implement an object", function() {
                var Dog = prime({
                    inherits: Animal
                });
                Dog.implement(new Actions());
                var rover = new Dog("rover");
                expect(rover.name).to.be("rover");
                expect(rover.jump()).to.be("actions:jump:rover");
                expect(rover.sleep()).to.be("actions:sleep:rover");
            });
            it("should implement any number of objects", function() {
                var Dog = prime({
                    inherits: Animal
                });
                Dog.implement(new Actions()).implement(new Attributes());
                var rover = new Dog("rover");
                expect(rover.name).to.be("rover");
                expect(rover.jump()).to.be("actions:jump:rover");
                expect(rover.sleep()).to.be("actions:sleep:rover");
                expect(rover.size()).to.be("attributes:size:rover");
                expect(rover.color()).to.be("attributes:color:rover");
            });
            it("should implement key-value objects", function() {
                var Dog = prime({
                    inherits: Animal
                });
                Dog.implement({
                    bark: function() {
                        return "woof!";
                    },
                    jump: function() {
                        return "jump";
                    }
                });
                var rover = new Dog("rover");
                expect(rover.bark()).to.be("woof!");
                expect(rover.jump()).to.be("jump");
            });
        });

        describe("prime toString", function() {
            it("should allow to implement toString", function() {
                var Person = prime({
                    constructor: function(name) {
                        this.name = name;
                    },
                    toString: function() {
                        return this.name;
                    }
                });
                var Italian = prime({
                    inherits: Person,
                    toString: function() {
                        return "It's me, " + this.name;
                    }
                });
                expect(new Person("Valerio") + "").to.be("Valerio");
                expect(new Italian("Valerio") + "").to.be("It's me, Valerio");
            });
        });
    },
    "1l": function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var array = require("3");

        describe("array", function() {
            // https://github.com/visionmedia/mocha/issues/502#issuecomment-7317552
            beforeEach(function(done) {
                setTimeout(done, 0);
            });
            // describe('set', function(){
            //     it('should set a value of the array', function(){
            //         var a = ['bar']
            //         expect(a[0]).to.be('bar')
            //         array.set(a, 0, 'foo')
            //         expect(a[0]).to.be('foo')
            //     })
            // })
            // describe('get', function(){
            //     it('should get an value from the array', function(){
            //         var a = ['bar', 'foo']
            //         expect(array.get(a, 1)).to.be('foo')
            //     })
            //     it('should return null if the key is not in the array', function(){
            //         var a = ['bar', 'foo']
            //         expect(array.get(a, 2)).to.be(null)
            //     })
            // })
            // describe('count', function(){
            //     it('should count the number of items in the array', function(){
            //         expect(array.count([1, 2, 3, 4])).to.be(4)
            //     })
            //     it('should return the number of items in an array-like object', function(){
            //         expect(array.count({length: 2, "0": 1, "1": 2})).to.be(2)
            //     })
            // })
            describe("each", function() {
                it("should iterate through the array, and stop when the function returns false", function() {
                    var values = [], keys = [], arrays = [], contexts = [];
                    var a = {
                        length: 3,
                        "0": 1,
                        "1": 2,
                        "2": 3
                    };
                    array.forEach(a, function(value, key, list) {
                        values.push(value);
                        keys.push(key);
                        arrays.push(list);
                        contexts.push(this);
                        if (key == 1) return false;
                    }, "context");
                    expect(values).to.eql([ 1, 2 ]);
                    expect(keys).to.eql([ 0, 1 ]);
                    expect(arrays).to.eql([ a, a ]);
                    expect(contexts).to.eql([ "context", "context" ]);
                });
            });
            // describe('backwards', function(){
            //     it('should iterate backwards through the array, and stop when the function returns false', function(){
            //         var values = [], keys = [], arrays = [], contexts = []
            //         var a = {length: 3, "0": 1, "1": 2, "2": 3}
            //         array.backwards(a, function(value, key, list){
            //             values.push(value)
            //             keys.push(key)
            //             arrays.push(list)
            //             contexts.push(this)
            //             if (key == 1) return false
            //         }, "context")
            //         expect(values).to.eql([3, 2])
            //         expect(keys).to.eql([2, 1])
            //         expect(arrays).to.eql([a, a])
            //         expect(contexts).to.eql(["context", "context"])
            //     })
            // })
            describe("indexOf", function() {
                it("should get the index of a specific item in the array", function() {
                    expect(array.indexOf([ 1, 2, 3 ], 2)).to.be(1);
                });
                it("should return -1 if the item is not in the array", function() {
                    expect(array.indexOf([ 1, 2, 3 ], 5)).to.be(-1);
                });
            });
            describe("remove", function() {
                it("should remove an item from the array and return the index", function() {
                    var a = [ 1, 2, 3, 4 ];
                    var ret = array.remove(a, 2);
                    expect(a).to.eql([ 1, 3, 4 ]);
                    expect(ret).to.be(1);
                });
                it("should return -1 when there is nothing to remove", function() {
                    var a = [ 1, 2, 3, 4 ];
                    var ret = array.remove(a, 10);
                    expect(a).to.eql([ 1, 2, 3, 4 ]);
                    expect(ret).to.be(-1);
                });
            });
        });
    },
    "1m": function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var date = require("n");

        describe("shell/date", function() {
            it("should export the date shell", function() {
                expect(date != null).to.be.ok();
                expect(date.now()).to.be.a("number");
            });
        });
    },
    "1n": function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var fn = require("q");

        describe("shell/function", function() {
            it("should export the function shell", function() {
                expect(fn != null).to.be.ok();
                expect(fn.apply(function() {
                    return 1;
                })).to.be.a("number");
            });
        });
    },
    "1o": function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var number = require("t");

        describe("types/number", function() {
            describe("limit", function() {
                it("should limit numbers", function() {
                    expect(number.limit(1, 3, 8)).to.be(3);
                    expect(number.limit(5, 3, 8)).to.be(5);
                    expect(number.limit(9, 3, 8)).to.be(8);
                });
            });
            describe("round", function() {
                it("should round numbers if no precision is specified", function() {
                    expect(number.round(3.14)).to.be(3);
                });
                it("should round numbers according to the units place specified", function() {
                    expect(number.round(.01, 2)).to.equal(.01);
                    expect(number.round(1, 3)).to.equal(1);
                    expect(number.round(-1.01)).to.equal(-1);
                    expect(number.round(-1.01, 2)).to.equal(-1.01);
                    expect(number.round(111, -1)).to.equal(110);
                    expect(number.round(-111, -2)).to.equal(-100);
                    expect(number.round(100, -5)).to.equal(0);
                });
            });
            describe("times", function() {
                it("should call a function n times", function() {
                    var buffer1 = [], buffer2 = [], buffer3 = [], buffer4 = [];
                    number.times(5, function(i, j, k) {
                        buffer1.push(i);
                        buffer2.push(j);
                        buffer3.push(+k);
                        buffer4.push(this);
                    }, 1);
                    expect(buffer1).to.eql([ 0, 1, 2, 3, 4 ]);
                    expect(buffer2).to.eql([ null, null, null, null, null ]);
                    expect(buffer3).to.eql([ 5, 5, 5, 5, 5 ]);
                    expect(buffer4).to.eql([ 1, 1, 1, 1, 1 ]);
                });
                it("should not call the function if the number is 0", function() {
                    var n = 0;
                    number.times(0, function() {
                        n++;
                    });
                    expect(n).to.be(0);
                });
            });
            describe("random", function() {
                it("should create a random number", function() {
                    for (var i = 0; i < 100; i++) {
                        var min = 50 - 1, max = 51 + i;
                        var random = number.random(min, max);
                        expect(random >= min && random <= max).to.be.ok();
                    }
                });
                it("should return the same number if the min and max are equal", function() {
                    expect(number.random(20, 20)).to.be(20);
                });
            });
        });
    },
    "1p": function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var hash = require("z");

        describe("hash", function() {
            // describe('set', function(){
            //     it('should set a value of the object', function(){
            //         var object = {}
            //         expect(object.name).to.be(undefined)
            //         hash.set(object, 'name', 'John')
            //         expect(object.name).to.be('John')
            //     })
            // })
            // describe('get', function(){
            //     it('should get an value from the object', function(){
            //         var object = {name: 'John'}
            //         expect(hash.get(object, 'name')).to.be('John')
            //     })
            //     it('should return null if the property does not exist', function(){
            //         var object = {name: 'John'}
            //         expect(hash.get(object, 'firstName')).to.be(null)
            //     })
            // })
            // describe('count', function(){
            //     it('should count the number of items in the object', function(){
            //         var object = {a: 1, b: 2, c: 3}
            //         expect(hash.count(object)).to.be(3)
            //     })
            // })
            describe("each", function() {
                it("should iterate through the object, and stop when the function returns false", function() {
                    var object = {
                        a: 1,
                        b: 2,
                        c: 3,
                        d: 4,
                        e: 5,
                        f: 6
                    };
                    var values = [], keys = [], objects = [], contexts = [];
                    hash.forIn(object, function(value, key, obj) {
                        values.push(value);
                        keys.push(key);
                        objects.push(obj);
                        contexts.push(this);
                        if (key == "d") return false;
                    }, "context");
                    expect(values).to.eql([ 1, 2, 3, 4 ]);
                    expect(keys).to.eql([ "a", "b", "c", "d" ]);
                    expect(objects).to.eql([ object, object, object, object ]);
                    expect(contexts).to.eql([ "context", "context", "context", "context" ]);
                });
            });
            describe("map", function() {
                it("should map the values of an object into a new object", function() {
                    var object = {
                        a: 1,
                        b: 2,
                        c: 3
                    }, ctx = {};
                    var contexts = [], objects = [];
                    var mapped = hash.map(object, function(val, key, obj) {
                        objects.push(obj);
                        contexts.push(this);
                        return key.charCodeAt(0) + val;
                    }, ctx);
                    expect(objects).to.eql([ object, object, object ]);
                    expect(contexts).to.eql([ ctx, ctx, ctx ]);
                    expect(mapped).to.eql({
                        a: 98,
                        b: 100,
                        c: 102
                    });
                    expect(mapped === object).not.to.be.ok();
                });
            });
            describe("filter", function() {
                it("should filter values from an object, and return a new object", function() {
                    var object = {
                        a: 1,
                        b: 2,
                        c: 3
                    }, ctx = {};
                    var contexts = [], objects = [];
                    var filtered = hash.filter(object, function(val, key, obj) {
                        objects.push(obj);
                        contexts.push(this);
                        return key.charCodeAt(0) > 97;
                    }, ctx);
                    expect(objects).to.eql([ object, object, object ]);
                    expect(contexts).to.eql([ ctx, ctx, ctx ]);
                    expect(filtered).to.eql({
                        b: 2,
                        c: 3
                    });
                    expect(filtered === object).not.to.be.ok();
                });
            });
            describe("every", function() {
                it("should return true if the function returns true for every value in the object", function() {
                    var object = {
                        a: 1,
                        b: 2,
                        c: 3
                    }, ctx = {};
                    var contexts = [], objects = [];
                    var every = hash.every(object, function(val, key, obj) {
                        objects.push(obj);
                        contexts.push(this);
                        return key.charCodeAt(0) + val > 97;
                    }, ctx);
                    expect(objects).to.eql([ object, object, object ]);
                    expect(contexts).to.eql([ ctx, ctx, ctx ]);
                    expect(every).to.equal(true);
                });
                it("should return false if the function does not returns true for every value in the object", function() {
                    var object = {
                        a: 1,
                        b: 2,
                        c: 3
                    };
                    var every = hash.every(object, function(val, key, obj) {
                        return key.charCodeAt(0) > 97;
                    });
                    expect(every).to.equal(false);
                });
            });
            describe("some", function() {
                it("should return true if the function returns true for some value in the object", function() {
                    var object = {
                        a: 1,
                        b: 2,
                        c: 3
                    }, ctx = {};
                    var contexts = [], objects = [];
                    var some = hash.some(object, function(val, key, obj) {
                        objects.push(obj);
                        contexts.push(this);
                        return key.charCodeAt(0) + val >= 100;
                    }, ctx);
                    expect(objects).to.eql([ object, object ]);
                    expect(contexts).to.eql([ ctx, ctx ]);
                    expect(some).to.equal(true);
                });
                it("should return false if the function does not returns true for any value in the object", function() {
                    var object = {
                        a: 1,
                        b: 2,
                        c: 3
                    };
                    var some = hash.some(object, function(val, key, obj) {
                        return key.charCodeAt(0) > 200;
                    });
                    expect(some).to.equal(false);
                });
            });
            describe("index", function() {
                it("should get the index of a specific item in the object", function() {
                    expect(hash.indexOf({
                        a: 1,
                        b: 2,
                        c: 3
                    }, 2)).to.be("b");
                });
                it("should return null if the item is not in the object", function() {
                    expect(hash.indexOf({
                        a: 1,
                        b: 2,
                        c: 3
                    }, 5)).to.be(null);
                });
            });
            describe("remove", function() {
                it("should remove an item from the object and return the key", function() {
                    var object = {
                        name: "John"
                    };
                    expect(object.name).to.be("John");
                    var ret = hash.remove(object, "John");
                    expect(object.name).to.be(undefined);
                    expect(ret).to.be("name");
                });
            });
            describe("keys", function() {
                it("should return an array with the keys of the object", function() {
                    expect(hash.keys({
                        a: 1,
                        b: 2,
                        c: 3,
                        d: 4
                    })).to.eql([ "a", "b", "c", "d" ]);
                });
            });
            describe("values", function() {
                it("should return an array with the values of the object", function() {
                    expect(hash.values({
                        a: 1,
                        b: 2,
                        c: 3,
                        d: 4
                    })).to.eql([ 1, 2, 3, 4 ]);
                });
            });
        });
    },
    "1q": function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var regexp = require("1a");

        describe("shell/regexp", function() {
            it("should export the regexp shell", function() {
                expect(regexp != null).to.be.ok();
                expect(regexp.test(/a/, "a")).to.be.ok();
                expect(regexp.exec(/a/, "a").join()).to.eql("a");
            });
        });
    },
    "1r": function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var string = require("1c");

        describe("types/string", function() {
            describe("clean", function() {
                it("should clean all extraneous whitespace from the string", function() {
                    expect(string.clean("  i     like    cookies   ")).to.equal("i like cookies");
                    expect(string.clean("  i\nlike \n cookies \n	  ")).to.equal("i like cookies");
                });
            });
            describe("camelize", function() {
                it("should convert a hyphenated string into a camel cased string", function() {
                    expect(string.camelize("i-like-cookies")).to.equal("iLikeCookies");
                    expect(string.camelize("I-Like-Cookies")).to.equal("ILikeCookies");
                });
            });
            describe("hyphenate", function() {
                it("should convert a camel cased string into a hyphenated string", function() {
                    expect(string.hyphenate("iLikeCookies")).to.equal("i-like-cookies");
                    expect(string.hyphenate("ILikeCookies")).to.equal("-i-like-cookies");
                });
            });
            describe("capitalize", function() {
                it("should capitalize each word", function() {
                    expect(string.capitalize("i like cookies")).to.equal("I Like Cookies");
                    expect(string.capitalize("I Like cOOKIES")).to.equal("I Like COOKIES");
                });
            });
            describe("escape", function() {
                it("should escape regex characters so it can be used in a regex", function() {
                    var original = "a./*[](){}$^+-_\\|";
                    var escaped = string.escape(original);
                    expect(escaped).to.equal("a\\.\\/\\*\\[\\]\\(\\)\\{\\}\\$\\^\\+\\-_\\\\\\|");
                    expect(function() {
                        new RegExp(escaped);
                    }).not.to.throwException();
                });
            });
        });
    },
    "1s": function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var ghost = require("1t");

        var array = require("3");

        var string = require("1c");

        var prime = require("5");

        describe("shell", function() {
            // https://github.com/visionmedia/mocha/issues/502#issuecomment-7317552
            beforeEach(function(done) {
                setTimeout(done, 0);
            });
            it("should ghost types for chaining methods", function() {
                expect(ghost([ 1, 2, 3 ]).join().valueOf()).to.equal("1,2,3");
                expect(ghost("  1,A,F   ").trim().split(",").map(function(value) {
                    return parseInt(value, 16);
                }).valueOf()).to.eql([ 1, 10, 15 ]);
            });
            it("should use valueOf automatically", function() {
                expect(ghost("abcd").indexOf("c").is(2)).to.be.ok();
                expect(ghost("abcd").indexOf("c") + 1).to.equal(3);
            });
            it("should return a string when ghost.toString() is called", function() {
                expect(ghost("foo").split("").toString()).to.equal("f,o,o");
            });
            it("should use ghost.is() to test if the value of the ghost is a value", function() {
                expect(ghost("ping").is("random")).not.to.be.ok();
                expect(ghost("ping").is("ping")).to.be.ok();
            });
            it("should add new methods to the base object when a method is implemented in the ghost", function() {
                string.implement({
                    cat: function(b) {
                        return this + b;
                    }
                });
                expect(string.cat("first", "second")).to.be("firstsecond");
            });
            it("should allow typecasting", function() {
                (function() {
                    expect(array(arguments).join().valueOf()).to.equal("1,2,3,4");
                })(1, 2, 3, 4);
            });
        });
    },
    "1t": function(require, module, exports, global) {
        /*
shell
*/
                "use strict";

        var shell = require("4");

        require("3");

        require("z");

        require("1c");

        require("t");

        require("q");

        require("n");

        require("1a");

        module.exports = shell;
    },
    "1u": function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var emitter = require("1v");

        describe("emitter", function() {
            it("should allow subscriptions with on, async emit", function(done) {
                var publisher = new emitter(), called = 0;
                publisher.on("publish", function() {
                    called++;
                    done();
                });
                expect(called).to.be(0);
                publisher.emit("publish");
            });
            it("should allow unsubscription with off, async emit", function(done) {
                var publisher = new emitter();
                publisher.on("publish", done);
                publisher.emit("publish");
                publisher.off("publish", done);
                publisher.on("publish", done);
                publisher.emit("publish");
            });
            it("should not add the same listener twice", function(done) {
                var events = new emitter(), called = 0;
                var listener = function() {
                    done();
                };
                events.on("thing", listener);
                events.on("thing", listener);
                events.emit("thing");
            });
            it("should not remove listeners of a different type", function(done) {
                var events = new emitter(), calledA = 0, calledB = 0;
                var doneA = function() {
                    calledA++;
                    if (calledB === 2 && calledA === 2) done();
                };
                var doneB = function() {
                    calledB++;
                    if (calledB === 2 && calledA === 2) done();
                };
                events.on("thing", doneA);
                events.on("thang", doneB);
                events.emit("thing");
                events.emit("thang");
                events.off("thing", doneB);
                events.emit("thing");
                events.emit("thang");
            });
        });
    },
    "1v": function(require, module, exports, global) {
        /*
Emitter
*/
                "use strict";

        var prime = require("5"), defer = require("1w"), slice = Array.prototype.slice;

        var EID = 0;

        module.exports = prime({
            on: function(event, fn) {
                var listeners = this._listeners || (this._listeners = {}), events = listeners[event] || (listeners[event] = {});
                for (var k in events) if (events[k] === fn) return this;
                events[(EID++).toString(36)] = fn;
                return this;
            },
            off: function(event, fn) {
                var listeners = this._listeners, events, key, length = 0;
                if (listeners && (events = listeners[event])) {
                    for (var k in events) {
                        length++;
                        if (key == null && events[k] === fn) key = k;
                        if (key && length > 1) break;
                    }
                    if (key) {
                        delete events[key];
                        if (length === 1) {
                            delete listeners[event];
                            for (var l in listeners) return this;
                            delete this._listeners;
                        }
                    }
                }
                return this;
            },
            emit: function(event) {
                var listeners = this._listeners, events;
                if (listeners && (events = listeners[event])) {
                    var args = arguments.length > 1 ? slice.call(arguments, 1) : [];
                    defer(function() {
                        var copy = {};
                        for (var k in events) copy[k] = events[k];
                        for (var k in copy) copy[k].apply(this, args);
                    });
                }
                return this;
            }
        });
    },
    "1w": function(require, module, exports, global) {
        /*
defer
*/
                "use strict";

        var deferred = {
            timeout: {},
            frame: {},
            immediate: {}
        };

        var UID = 0;

        var _defer = function(type, callback, arg) {
            var collection = deferred[type], method = functions[type];
            var empty = true;
            for (var p in collection) {
                empty = false;
                break;
            }
            var uid = (UID++).toString(36);
            if (empty) method(arg);
            collection[uid] = callback;
            return function() {
                delete collection[uid];
            };
        };

        var iterate = function(collection) {
            var time = new Date().getTime();
            var exec = {};
            for (var p in collection) {
                exec[p] = collection[p];
                delete collection[p];
            }
            for (var p in exec) exec[p](time);
        };

        var immediate = function() {
            iterate(deferred.immediate);
        };

        var functions = {};

        if (global.process && process.nextTick) {
            functions.immediate = function() {
                process.nextTick(immediate);
            };
        } else if (global.setImmediate) {
            functions.immediate = function() {
                setImmediate(immediate);
            };
        } else if (global.postMessage && global.addEventListener) {
            addEventListener("message", function(event) {
                if (event.source === global && event.data === "@deferred") {
                    event.stopPropagation();
                    immediate();
                }
            }, true);
            functions.immediate = function() {
                postMessage("@deferred", "*");
            };
        } else {
            functions.immediate = function() {
                setTimeout(immediate, 0);
            };
        }

        var requestAnimationFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame || global.msRequestAnimationFrame || function(callback) {
            setTimeout(callback, 1e3 / 60);
        };

        functions.frame = function() {
            requestAnimationFrame(function() {
                iterate(deferred.frame);
            });
        };

        functions.timeout = function(ms) {
            var timeout = deferred.timeout;
            var collection = timeout[ms] || (timeout[ms] = {});
            setTimeout(function() {
                iterate(collection);
            }, ms);
        };

        /*
export!
*/
        var defer = function(callback, ms) {
            return ms ? _defer("timeout", callback, ms) : _defer("immediate", callback);
        };

        defer.immediate = function(callback) {
            return _defer("immediate", callback);
        };

        defer.timeout = function(callback, ms) {
            if (!ms) ms = 0;
            return _defer("timeout", callback, ms);
        };

        defer.frame = function(callback) {
            return _defer("frame", callback);
        };

        module.exports = defer;
    },
    "1x": function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var Map = require("1y");

        describe("map", function() {
            // https://github.com/visionmedia/mocha/issues/502#issuecomment-7317552
            beforeEach(function(done) {
                setTimeout(done, 0);
            });
            describe("set / get", function() {
                it("should set and get a value from the map", function() {
                    var map = new Map();
                    var object = {};
                    map.set(object, "bar");
                    map.set("bar", object);
                    expect(map.get(object)).to.be("bar");
                    expect(map.get("bar")).to.be(object);
                });
                it("should overwrite a value", function() {
                    var map = new Map();
                    map.set("bar", "foo");
                    expect(map.get("bar")).to.be("foo");
                    map.set("bar", "wop");
                    expect(map.get("bar")).to.be("wop");
                });
            });
            describe("count", function() {
                it("should count the number of values in the map", function() {
                    var map = new Map();
                    map.set("bar", "foo").set("foo", "bar");
                    expect(map.count()).to.be(2);
                });
            });
            describe("each", function() {
                it("Iterates over a map instance, and stop when false is returned", function() {
                    var map = new Map(), keys = [], values = [], ctxs = [], maps = [], ctx = {};
                    map.set("bar", "foo").set("foo", "bar").set("b", 1);
                    map.forEach(function(val, key, mp) {
                        keys.push(key);
                        values.push(val);
                        ctxs.push(this);
                        maps.push(mp);
                        if (key == "foo") return false;
                    }, ctx);
                    expect(keys).to.eql([ "bar", "foo" ]);
                    expect(values).to.eql([ "foo", "bar" ]);
                    expect(ctxs).to.eql([ ctx, ctx ]);
                    expect(maps).to.eql([ map, map ]);
                });
            });
            // describe('backwards', function(){
            //     it('Iterates over a map instance backwards, and stop when false is returned', function(){
            //         var map = new Map(), keys = [], values = [], ctxs = [], maps = [], ctx = {}
            //         map.set('bar', 'foo').set('foo', 'bar').set('b', 1)
            //         map.backwards(function(val, key, mp){
            //             keys.push(key)
            //             values.push(val)
            //             ctxs.push(this)
            //             maps.push(mp)
            //             if (key == 'foo') return false
            //         }, ctx)
            //         expect(keys).to.eql(['b', 'foo'])
            //         expect(values).to.eql([1, 'bar'])
            //         expect(ctxs).to.eql([ctx, ctx])
            //         expect(maps).to.eql([map, map])
            //     })
            // })
            describe("map", function() {
                it("map the values in the map", function() {
                    var map = new Map(), keys = [], values = [], ctxs = [], maps = [], ctx = {};
                    map.set("bar", "foo").set("foo", "bar").set("b", 1);
                    var result = map.map(function(val, key, mp) {
                        keys.push(key);
                        values.push(val);
                        ctxs.push(this);
                        maps.push(mp);
                        return key;
                    }, ctx);
                    expect(keys).to.eql([ "bar", "foo", "b" ]);
                    expect(values).to.eql([ "foo", "bar", 1 ]);
                    expect(ctxs).to.eql([ ctx, ctx, ctx ]);
                    expect(maps).to.eql([ map, map, map ]);
                    expect(result === map).not.to.be.ok();
                    expect(result.get("bar")).to.be("bar");
                    expect(result.get("foo")).to.be("foo");
                });
            });
            describe("filter", function() {
                it("filter the values in the map", function() {
                    var map = new Map(), keys = [], values = [], ctxs = [], maps = [], ctx = {}, a = {}, b = {};
                    map.set("bar", a).set("foo", b).set("b", 1);
                    var result = map.filter(function(val, key, mp) {
                        keys.push(key);
                        values.push(val);
                        ctxs.push(this);
                        maps.push(mp);
                        return typeof val == "object";
                    }, ctx);
                    expect(keys).to.eql([ "bar", "foo", "b" ]);
                    expect(values).to.eql([ a, b, 1 ]);
                    expect(ctxs).to.eql([ ctx, ctx, ctx ]);
                    expect(maps).to.eql([ map, map, map ]);
                    expect(result === map).not.to.be.ok();
                    expect(result.get("bar")).to.be(a);
                    expect(result.get("foo")).to.be(b);
                    expect(result.get("b")).to.be(null);
                });
            });
            describe("every", function() {
                it("return true if every value is ok", function() {
                    var map = new Map(), keys = [], values = [], ctxs = [], maps = [], ctx = {};
                    map.set("bar", 2).set("foo", 0).set("b", 1);
                    var result = map.every(function(val, key, mp) {
                        keys.push(key);
                        values.push(val);
                        ctxs.push(this);
                        maps.push(mp);
                        return val < 5;
                    }, ctx);
                    expect(keys).to.eql([ "bar", "foo", "b" ]);
                    expect(values).to.eql([ 2, 0, 1 ]);
                    expect(ctxs).to.eql([ ctx, ctx, ctx ]);
                    expect(maps).to.eql([ map, map, map ]);
                    expect(result).to.be(true);
                });
                it("should return false if not true is returned for each value", function() {
                    var map = new Map();
                    map.set("bar", 2).set("foo", 0).set("b", 1);
                    var result = map.every(function(val, key, mp) {
                        return val < 1;
                    });
                    expect(result).to.be(false);
                });
            });
            describe("some", function() {
                it("return false if every value is not ok", function() {
                    var map = new Map(), keys = [], values = [], ctxs = [], maps = [], ctx = {};
                    map.set("bar", 2).set("foo", 0).set("b", 1);
                    var result = map.some(function(val, key, mp) {
                        keys.push(key);
                        values.push(val);
                        ctxs.push(this);
                        maps.push(mp);
                        return val > 5;
                    }, ctx);
                    expect(keys).to.eql([ "bar", "foo", "b" ]);
                    expect(values).to.eql([ 2, 0, 1 ]);
                    expect(ctxs).to.eql([ ctx, ctx, ctx ]);
                    expect(maps).to.eql([ map, map, map ]);
                    expect(result).to.be(false);
                });
                it("should return true if true is returned for some value", function() {
                    var map = new Map();
                    map.set("bar", 2).set("foo", 0).set("b", 1);
                    var result = map.some(function(val, key, mp) {
                        return val < 1;
                    });
                    expect(result).to.be(true);
                });
            });
            describe("index", function() {
                it("should return the key which is assiciated with a value", function() {
                    var map = new Map(), obj = {};
                    map.set("bar", 2).set(obj, 0).set("moo", 0).set("b", 1);
                    expect(map.indexOf(0)).to.be(obj);
                });
            });
            describe("remove", function() {
                it("should remove a value and return the key", function() {
                    var map = new Map(), obj1 = {}, obj2 = {};
                    map.set("bar", 2).set(obj1, obj2).set("moo", 0).set("b", 1);
                    expect(map.remove(obj2)).to.be(obj1);
                    expect(map.remove(obj2)).to.be(null);
                });
            });
            describe("keys", function() {
                it("should return an array with the keys of the map", function() {
                    var map = new Map(), obj = {};
                    map.set("bar", 2).set(obj, 0).set("moo", 0).set("b", 1);
                    expect(map.keys()).to.eql([ "bar", obj, "moo", "b" ]);
                });
            });
            describe("get", function() {
                it("should return an array with the values of the map", function() {
                    var map = new Map(), obj = {};
                    map.set("bar", 2).set(obj, 0).set("moo", 0).set("b", 1);
                    expect(map.values()).to.eql([ 2, 0, 0, 1 ]);
                });
            });
        });
    },
    "1y": function(require, module, exports, global) {
        /*
Map
*/
                "use strict";

        var prime = require("5"), indexOf = require("g");

        var Map = prime({
            constructor: function() {
                if (!this instanceof Map) return new Map();
                this.length = 0;
                this._values = [];
                this._keys = [];
            },
            set: function(key, value) {
                var index = indexOf(this._keys, key);
                if (index === -1) {
                    this._keys.push(key);
                    this._values.push(value);
                    this.length++;
                } else {
                    this._values[index] = value;
                }
                return this;
            },
            get: function(key) {
                var index = indexOf(this._keys, key);
                return index === -1 ? null : this._values[index];
            },
            count: function() {
                return this.length;
            },
            forEach: function(method, context) {
                for (var i = 0, l = this.length; i < l; i++) {
                    if (method.call(context, this._values[i], this._keys[i], this) === false) break;
                }
                return this;
            },
            map: function(method, context) {
                var results = new Map();
                this.forEach(function(value, key) {
                    results.set(key, method.call(context, value, key, this));
                }, this);
                return results;
            },
            filter: function(method, context) {
                var results = new Map();
                this.forEach(function(value, key) {
                    if (method.call(context, value, key, this)) results.set(key, value);
                }, this);
                return results;
            },
            every: function(method, context) {
                var every = true;
                this.forEach(function(value, key) {
                    if (!method.call(context, value, key, this)) return every = false;
                }, this);
                return every;
            },
            some: function(method, context) {
                var some = false;
                this.forEach(function(value, key) {
                    if (method.call(context, value, key, this)) return !(some = true);
                }, this);
                return some;
            },
            indexOf: function(value) {
                var index = indexOf(this._values, value);
                return index > -1 ? this._keys[index] : null;
            },
            remove: function(value) {
                var index = indexOf(this._values, value);
                if (index !== -1) {
                    this._values.splice(index, 1);
                    this.length--;
                    return this._keys.splice(index, 1)[0];
                }
                return null;
            },
            unset: function(key) {
                var index = indexOf(this._keys, key);
                if (index !== -1) {
                    this._keys.splice(index, 1);
                    this.length--;
                    return this._values.splice(index, 1)[0];
                }
                return null;
            },
            keys: function() {
                return this._keys.slice();
            },
            values: function() {
                return this._values.slice();
            }
        });

        module.exports = Map;
    },
    "1z": function(require, module, exports, global) {
                "use strict";

        var expect = require("2");

        var type = require("c");

        describe("type", function() {
            it("should return 'array' for Array objects", function() {
                expect(type([ 1, 2 ])).to.equal("array");
            });
            it("should return 'string' for String objects", function() {
                expect(type("ciao")).to.equal("string");
            });
            it("should return 'regexp' for RegExp objects", function() {
                expect(type(/_/)).to.equal("regexp");
            });
            it("should return 'function' for Function objects", function() {
                expect(type(function() {})).to.equal("function");
            });
            it("should return 'number' for Number objects", function() {
                expect(type(10)).to.equal("number");
                expect(type(Infinity)).to.equal("number");
            });
            it("should return 'null' for NaN", function() {
                expect(type(NaN)).to.equal("null");
            });
            it("should return 'boolean' for Boolean objects", function() {
                expect(type(true)).to.equal("boolean");
                expect(type(false)).to.equal("boolean");
            });
            it("should return 'object' for objects", function() {
                expect(type({
                    a: 2
                })).to.equal("object");
                expect(type(arguments)).to.equal("object");
            });
            it("should return 'null' for null objects", function() {
                expect(type(null)).to.equal("null");
            });
            it("should return 'null' for undefined objects", function() {
                expect(type(undefined)).to.equal("null");
            });
        });
    }
});